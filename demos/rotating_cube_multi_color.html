<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Colored ASCII Cube</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <script src="./html2canvas.min.js"></script>
    <script src="./gif.js"></script>
    <script src="./gif.worker.js"></script>
    <style>
        body {
            background: black;
            color: white;
            font-family: monospace;
            white-space: pre;
            font-size: 10px;
            line-height: 8px;
        }
        #canvas {
            display: inline-block;
        }
        .face1 { color: #FF0000; }
        .face2 { color: #FFA500; }
        .face3 { color: #FFFF00; }
        .face4 { color: #008000; }
        .face5 { color: #1E90FF; }
        .face6 { color: #6A5ACD; }
    </style>
</head>
<body>
<div id="inputs">
<div>
<label for="cube-character">Character</label><br>
<input type="text" id="cube-character" minlength="1" maxlength="1" value="+" size="20">
</div>
<div>
<label for="cube-font-size">Font Size</label><br>
<input type="number" id="cube-font-size" max="50" value=10 size="24">
</div>
<div>
<label for="cube-speed">Rotation Speed</label><br>
<input type="range" id="cube-speed" min="0" max="20" value="4"><span id="cube-speed-text">4</span>
<button id="decrease-button">-</button><button id="increase-button">+</button><button id="increment-button">step</button>
</div>
<div>
<label for="cube-saturation">Saturation/Lightness</label><br>
<input type="number" id="cube-saturation" min="0" max="100" value="100"><input type="number" id="cube-lightness" min="0" max="100" value="50">
</div>
<div><button id="randomize-font-color-button">Random Face Colors</button></div>
<div><button id="toggle-direction-button">Toggle Direction</button></div>
<div><button id="reset-button">Reset</button></div>
<div><button id="render-gif" style="display: none;">Render GIF</button><span id="gif-message"></span></div>
</div>
<pre id="canvas"></pre>

<script>
    if (window.location.protocol === "http:" || window.location.protocol === "https:") {
        document.getElementById("render-gif").style.display = "block";
    }

    const speedDefault = 4;
    const heightDefault = 30; //20; // Further reduced for performance
    const fontSizeDefault = 10;
    const ratio = 0.8;
    const hueDefault = 360;
    const saturationDefault = 100;
    const lightnessDefault = 50;
    const characterDefault = '+';
    const faceColorsDefault = ['#FF0000', '#FFAA00', '#FFFF00', '#00FF00', '#00AAFF', '#5500FF'];

    const canvas = document.getElementById("canvas");
    const speedText = document.getElementById("cube-speed-text");
    
    let angleA = 0;
    let angleB = 0;
    let height = heightDefault;
    let width = height * 1.4;
    let speed = speedDefault / 100;
    let character = characterDefault;
    let saturation = saturationDefault;
    let lightness = lightnessDefault;
    let toggleDirection = false;
    let rendered = false;
    let disco = false;
    let faceColors = [...faceColorsDefault];
    let frameCount = 0;

    // Color conversion functions
    function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    }

    function rgbToHsl(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
    }

    function hexToHue(hex) {
        const { r, g, b } = hexToRgb(hex);
        const hsl = rgbToHsl(r, g, b);
        return hsl[0]; // Hue is the first element
    }

    function hslToHex(h, s, l) {
        l /= 100;
        const a = s * Math.min(l, 1 - l) / 100;
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    }

    function getBrightRandomHexColorHSL() {
        return hslToHex(Math.floor(Math.random() * hueDefault), saturation, lightness);
    }

    // Event listeners
    document.getElementById("cube-saturation").addEventListener("change", e => {
        rendered = false;
        let saturationValue = parseInt(e.target.value);

        if (saturationValue < 0) {
            document.getElementById("cube-saturation").value = 0;
        } else if (saturationValue > 100) {
            document.getElementById("cube-saturation").value = 100;
        }

        saturation = Math.min(saturationValue || 1, 100);
        updateFaceColors();
        rendered = true;
    });

    document.getElementById("cube-lightness").addEventListener("change", e => {
        rendered = false;
        let lightnessValue = parseInt(e.target.value);

        if (lightnessValue < 0) {
            document.getElementById("cube-lightness").value = 0;
        } else if (lightnessValue > 100) {
            document.getElementById("cube-lightness").value = 100;
        }

        lightness = Math.min(lightnessValue || 1, 99);
        updateFaceColors();
        rendered = true;
    });

    function updateFaceColors() {
        faceColors = faceColors.map(hex => hslToHex(hexToHue(hex), saturation, lightness));
        updateCSSColors();
    }

    function updateCSSColors() {
        const styleSheet = document.styleSheets[0];
        for (let i = 0; i < 6; i++) {
            const ruleIndex = Array.from(styleSheet.cssRules).findIndex(r => r.selectorText === `.face${i + 1}`);
            if (ruleIndex !== -1) {
                styleSheet.deleteRule(ruleIndex);
            }
            styleSheet.insertRule(`.face${i + 1} { color: ${faceColors[i]}; }`, styleSheet.cssRules.length);
        }
    }

    document.getElementById("randomize-font-color-button").addEventListener("click", () => {
        rendered = false;
        faceColors = Array(6).fill().map(() => getBrightRandomHexColorHSL());
        updateCSSColors();
        rendered = true;
    });

    const speedPickerEl = document.getElementById("cube-speed");
    speedPickerEl.addEventListener("input", () => {
        rendered = false;
        speedText.textContent = speedPickerEl.value;
        speed = parseInt(speedPickerEl.value) / 100;
        rendered = true;
    });

    document.getElementById("decrease-button").addEventListener("click", () => {
        rendered = false;
        if (speedPickerEl.value > 0) {
            speedPickerEl.value--;
            speedText.textContent = speedPickerEl.value;
            speed = speedPickerEl.value / 100;
        }
        rendered = true;
    });

    document.getElementById("increase-button").addEventListener("click", () => {
        rendered = false;
        if (speedPickerEl.value < 20) {
            speedPickerEl.value++;
            speedText.textContent = speedPickerEl.value;
            speed = speedPickerEl.value / 100;
        }
        rendered = true;
    });

    document.getElementById("increment-button").addEventListener("click", () => {
        rendered = false;
        speedPickerEl.value = 0;
        speedText.textContent = 0;
        speed = 0.01;
        setTimeout(() => speed = 0, 0);
        rendered = true;
    });

    const cubeFontSizeEl = document.getElementById("cube-font-size");
    cubeFontSizeEl.addEventListener("change", () => {
        rendered = false;
        let fontSize = Math.min(Math.max(parseInt(cubeFontSizeEl.value) || fontSizeDefault, 1), 50);
        cubeFontSizeEl.value = fontSize;
        canvas.style.fontSize = `${fontSize}px`;
        canvas.style.lineHeight = `${fontSize * ratio}px`;
        rendered = true;
    });

    const characterPickerEl = document.getElementById("cube-character");
    characterPickerEl.addEventListener("input", () => {
        rendered = false;
        character = characterPickerEl.value.trim() || characterDefault;
        rendered = true;
    });

    document.getElementById("toggle-direction-button").addEventListener("click", () => {
        rendered = false;
        toggleDirection = !toggleDirection;
        rendered = true;
    });

    document.getElementById("reset-button").addEventListener("click", () => {
        rendered = false;
        character = characterDefault;
        characterPickerEl.value = characterDefault;
        cubeFontSizeEl.value = fontSizeDefault;
        canvas.style.fontSize = `${fontSizeDefault}px`;
        canvas.style.lineHeight = `${fontSizeDefault * ratio}px`;
        speedPickerEl.value = speedDefault;
        speedText.textContent = speedDefault;
        speed = speedDefault / 100;
        height = heightDefault;
        width = height * 1.4;
        saturation = saturationDefault;
        lightness = lightnessDefault;
        document.getElementById("cube-saturation").value = saturationDefault;
        document.getElementById("cube-lightness").value = lightnessDefault;
        toggleDirection = false;
        disco = false;
        faceColors = [...faceColorsDefault];
        document.getElementById("gif-version").remove();
        document.getElementById("gif-message").innerText = "";
        updateCSSColors();
        rendered = true;
    });

    document.addEventListener('keydown', (event) => {
        rendered = false;
        if (document.activeElement !== characterPickerEl) {
            switch (event.keyCode) {
                case 27: // esc - reset
                    document.getElementById("reset-button").click();
                    break;
                case 38: case 87: // up or w - increase font size
                    cubeFontSizeEl.value = Math.min(parseInt(cubeFontSizeEl.value || fontSizeDefault) + 1, 50);
                    canvas.style.fontSize = `${cubeFontSizeEl.value}px`;
                    canvas.style.lineHeight = `${cubeFontSizeEl.value * ratio}px`;
                    break;
                case 40: case 83: // down or s - decrease font size
                    cubeFontSizeEl.value = Math.max(parseInt(cubeFontSizeEl.value || fontSizeDefault) - 1, 1);
                    canvas.style.fontSize = `${cubeFontSizeEl.value}px`;
                    canvas.style.lineHeight = `${cubeFontSizeEl.value * ratio}px`;
                    break;
                case 39: case 68: // right or d - increase speed
                    if (speedPickerEl.value < 20) {
                        speedPickerEl.value++;
                        speedText.textContent = speedPickerEl.value;
                        speed = speedPickerEl.value / 100;
                    }
                    break;
                case 37: case 65: // left or a - decrease speed
                    if (speedPickerEl.value > 0) {
                        speedPickerEl.value--;
                        speedText.textContent = speedPickerEl.value;
                        speed = speedPickerEl.value / 100;
                    }
                    break;
                case 32: // space - pause
                    speedPickerEl.value = 0;
                    speedText.textContent = 0;
                    speed = 0;
                    break;
                case 84: // t - toggle direction
                    toggleDirection = !toggleDirection;
                    break;
                case 82: // r - random color
                    document.getElementById("randomize-font-color-button").click();
                    break;
                case 73: // i - increment frame
                    document.getElementById("increment-button").click();
                    break;
            }
        } else {
            character = event.key.trim().charAt(0) || characterDefault;
            characterPickerEl.value = character;
        }
        rendered = true;
    });

    function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function konamiCodeListener(callback) {
        let konamiCodePosition = 0;
        const konamiCode = ['up', 'up', 'down', 'down', 'left', 'right', 'left', 'right', 'b', 'a'];
        const konamiAllowedKeys = {
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            65: 'a',
            66: 'b',
            'ArrowLeft': 'left',
            'ArrowUp': 'up',
            'ArrowRight': 'right',
            'ArrowDown': 'down',
            'KeyA': 'a',
            'KeyB': 'b',
            'a': 'a',
            'b': 'b'
        };

        // add keydown event listener
        document.addEventListener('keyup', function(e) {
            // get the value of the key code from the key map
            const key = konamiAllowedKeys[e.key || e.code || e.which || e.keyCode];
            // get the value of the required key from the konami code
            const requiredKey = konamiCode[konamiCodePosition];
            // compare the key with the required key
            if (key === requiredKey) {
                // move to the next key in the konami code sequence
                konamiCodePosition++;

                // if the last key is reached, activate cheats
                if (konamiCodePosition === konamiCode.length) {
                    konamiCodePosition = 0;
                    callback(true);
                } else {
                    callback(false);
                }
            } else {
                konamiCodePosition = 0;
                callback(false);
            }
        });
    }

    function renderFrame() {
        if (speed === 0) {
            requestAnimationFrame(renderFrame);
            return;
        }

        const z = new Float32Array(width * height).fill(0);
        const b = new Array(width * height).fill(' ');
        const color = new Array(width * height).fill('');

        function plot(x, y, zVal, ch, faceClass) {
            const xp = Math.floor(width / 2 + x);
            const yp = Math.floor(height / 2 - y);
            const idx = xp + width * yp;
            if (xp >= 0 && xp < width && yp >= 0 && yp < height && zVal > z[idx]) {
                z[idx] = zVal;
                b[idx] = ch;
                color[idx] = faceClass;
            }
        }

        const vertices = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
            [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];

        const faces = [
            [0, 1, 2, 3, 'face1'], [4, 5, 6, 7, 'face2'],
            [0, 1, 5, 4, 'face3'], [2, 3, 7, 6, 'face4'],
            [0, 3, 7, 4, 'face5'], [1, 2, 6, 5, 'face6']
        ];

        function rotate(x, y, z) {
            const sinA = Math.sin(angleA), cosA = Math.cos(angleA);
            const sinB = Math.sin(angleB), cosB = Math.cos(angleB);
            const x1 = toggleDirection ? (x * cosB + z * sinB) : (x * cosB - z * sinB);
            const z1 = toggleDirection ? (x * sinB - z * cosB) : (x * sinB + z * cosB);
            const y1 = toggleDirection ? (y * cosA + z1 * sinA) : (y * cosA - z1 * sinA);
            const z2 = toggleDirection ? (y * sinA - z1 * cosA) : (y * sinA + z1 * cosA);
            return [x1, y1, z2 + 4];
        }

        for (const [a, b, c, d, faceClass] of faces) {
            const v = [vertices[a], vertices[b], vertices[c], vertices[d]].map(p => {
                if (!p || p.length !== 3) {
                    console.error('Invalid vertex:', p);
                    return [0, 0, 0]; // Fallback to prevent undefined errors
                }
                return rotate(...p);
            });
            // Debug log to check v
            if (!v.every(vec => Array.isArray(vec) && vec.length === 3)) {
                console.error('Invalid rotated vertices:', v);
                return; // Skip this frame to avoid crash
            }
            const steps = 5;
            for (let i = 0; i <= steps; i++) {
                for (let j = 0; j <= steps; j++) {
                    const u = i / steps, vVal = j / steps; // Renamed v to vVal to avoid shadowing
                    const x = (v[0][0] * (1 - u) + v[1][0] * u) * (1 - vVal) + (v[3][0] * (1 - u) + v[2][0] * u) * vVal;
                    const y = (v[0][1] * (1 - u) + v[1][1] * u) * (1 - vVal) + (v[3][1] * (1 - u) + v[2][1] * u) * vVal;
                    const zVal = (v[0][2] * (1 - u) + v[1][2] * u) * (1 - vVal) + (v[3][2] * (1 - u) + v[2][2] * u) * vVal;
                    plot(x * 10, y * 8, 1 / zVal, character, faceClass);
                }
            }
        }

        let frame = '';
        frameCount = b.length-1;
        for (let i = 0; i < b.length; i++) {
            if (i % width === 0) frame += '\n';

            let num = i;
            if (disco === true) {
                num = getRandomIntInclusive(0, b.length-1);
            }
            frame += color[i] ? `<span class="${color[num]}">${b[num]}</span>` : b[i];
        }

        canvas.innerHTML = frame;
        angleA += speed === 0.01 ? 0.008 : speed - 0.01;
        angleB += speed === 0.01 ? 0.009 : speed;
        requestAnimationFrame(renderFrame);
    }

    updateCSSColors();
    renderFrame();
    konamiCodeListener(function(flag) {
        if (flag) {
            disco = !disco;
        }
    });
    rendered = true;

    async function convertDivToGif(divId, frameCount, frameDelay) {
        frameCount = Math.floor(frameCount);
        console.log("adjustedFramecount:"+frameCount);

        const targetDiv = document.getElementById(divId);
        if (!targetDiv) {
            console.error("Div not found.");
            return;
        }

        const gif = new GIF({
            workers: 2, // Number of web workers to use for encoding
            quality: 10, // GIF quality (lower is smaller file size, but worse quality)
        });

        console.log("Setup GIF");

        for (let i = 0; i < frameCount; i++) {
            // Capture the div content for each frame
            //document.getElementById("increment-button").click();
            const canvas = await html2canvas(targetDiv);
            gif.addFrame(canvas, { delay: frameDelay });
            // console.log("Frame #:"+(i+1).toString()+" of "+frameCount.toString());
            document.getElementById("gif-message").innerText = "GIF creating canvas frames: " + Math.floor(((i+1)/frameCount)*100);
        }

        console.log("Added canvas to frames");

        gif.on('finished', function(blob) {
            console.log("finished");
            document.getElementById("gif-message").innerText = "GIF renderering finished";
            // Display the generated GIF
            const img = document.createElement('img');
            img.src = URL.createObjectURL(blob);
            img.setAttribute("id", "gif-version");
            document.body.appendChild(img);

            // Or offer for download
            // const a = document.createElement('a');
            // a.href = URL.createObjectURL(blob);
            // a.download = 'div_animation.gif';
            // a.click();
        });

        try {
            gif.render();
            console.log("GIF render");
            document.getElementById("gif-message").innerText = "GIF renderering";
        } catch(error) {
            console.log(error);
            console.log("Error");
            document.getElementById("gif-message").innerText = "Error: " + error.toString();
        }
    }

    // Example usage: Convert a div with ID into a GIF with 100ms delay per frame
    document.getElementById("render-gif").addEventListener("click", () => {
        if (rendered) {
            document.getElementById("gif-message").innerText = "Rendering GIF";
            console.log("originalFramecount:"+frameCount);
            convertDivToGif('canvas', 50, 100);
        }
    });
</script>
</body>
</html>