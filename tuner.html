<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Open Source Premium Metronome | Subdivisions, Tone Generator, Tuner, Presets</title>
    <meta name="description" content="The best open source, ad-free premium metronome. Includes subdivisions, tone generator, tuner, and preset saving for musicians.">
    <meta name="keywords" content="metronome, open source metronome, premium metronome, ad-free metronome, metronome with subdivisions, tone generator, tuner, presets, musician practice tool, classical music, violin, viola, cello, bass, wind instruments, brass">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Michael Yagi">
    <meta property="og:title" content="Premium Open Source Metronome">
    <meta property="og:description" content="Ad-free metronome with subdivisions, tone generator, tuner, and presets.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://michaelyagi.github.io/tuner.html">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* Reset body margins and prevent horizontal scroll */
        html, body {
            margin: 0;              /* remove default white margin */
            padding: 0;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;     /* stop sideways scrolling */
        }
        body {
            font-family: system-ui, sans-serif;
            margin: 0;          /* no external margin */
            padding-top: 20px;
            background-color: #111; /* try charcoal black */
            color: #eee;
        }
        h1 { margin-bottom: 12px; }
        h3 { margin-top: 0; }
        .box { border: 1px solid #ddd; border-radius: 8px; padding: 12px; margin-bottom: 20px; }
        label { font-weight: 600; }
        .metric { font-size: 2rem; }
        .sub { color: #666; }
        .needle { width: 100%; height: 10px; background: #eee; border-radius: 6px; position: relative; margin-top: 8px; }
        .needle > div { position: absolute; top: -6px; width: 2px; height: 22px; background: #333; left: 50%; transition: left 80ms linear; }
        .status { color: #444; font-size: 0.95rem; margin-top: 8px; }
        .dimmed { opacity: 0.4; }
        #noteDial { width: 100%; box-sizing: border-box; }
        /* Blinking red dot */
        #metronomeDot {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 8px;
            margin-bottom: 5px;
            border-radius: 50%;
            background-color: red;
            opacity: 0; /* hidden until pulse */
            vertical-align: middle;
            transition: opacity 0.1s ease;
        }
        #subdivisionDot {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 6px;
            margin-bottom: 5px;
            border-radius: 50%;
            background-color: blue; /* distinct color */
            opacity: 0;
            vertical-align: middle;
            transition: opacity 0.1s ease;
        }
        /* Animated wave */
        #toneWave {
            /* border: 1px solid #ddd; */
            margin-top: 12px;
            width: 100%;
        }
        #metronomeBox {
            user-select: none; /* prevent text highlight */
        }
        #presetsBox select, #presetsBox button {
            padding: 2px 4px;
            font-size: 0.85rem;
            height: 22px;
        }
        .sliderWrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .sliderNotch {
            position: absolute;
            top: 100%;
            left: 51%;              /* middle of the slider */
            width: 2px;
            height: 5px;
            background: #333;        /* notch color */
            transform: translate(-50%, -50%);
            pointer-events: none;    /* donâ€™t block slider interaction */
        }

        /* --- Korg-style overrides --- */
        .box {
            background: #111;
            color: #eee;
            border: 2px solid #333;
            border-radius: 12px;
            width: 100%;            /* fill available width */
            max-width: 400px;       /* cap size on larger screens */
            margin: 0 auto 20px;    /* center horizontally */
            box-sizing: border-box; /* include padding in width */
        }
        .box h3 {
            text-align: center;
            color: #ff6600;
            margin-bottom: 12px;
        }
        .box input[type=number],
        .box input[type=text],
        .box select {
            background: #0b1d3a;
            color: #ffcc00;
            border: none;
            font-size: 1rem;
            text-align: center;
            border-radius: 4px;
            padding: 2px 4px;
        }
        .box button {
            background: #222;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .box button:hover { background: #333; }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V9XXZTGS4W"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-V9XXZTGS4W');
    </script>
</head>
<body>
<!--<h1>ðŸŽµ Metronome, Tuner & Tone Generator</h1>-->

<!-- Metronome -->
<div class="box" id="metronomeBox">
    <h3>Metronome</h3>
    <label for="tempo">Tempo (BPM):</label>
    <input id="tempo" type="number" min="30" max="240" value="120" style="width:80px;">
    <button id="startMetronome">Start</button>
    <button id="stopMetronome">Stop</button>
    <div>
        <label for="subdivisions">Subdivisions:</label>
        <input id="subdivisions" type="number" min="1" value="1" style="width:60px;">
        <label for="clickSound">Click Sound:</label>
        <select id="clickSound">
            <option value="square">Square</option>
            <option value="sine">Sine</option>
            <option value="triangle">Triangle</option>
            <option value="sawtooth">Sawtooth</option>
        </select>
    </div>
    <div id="metronomeStatus" class="status">
        <span id="metronomeText">Stopped</span>
        <span id="metronomeDot"></span>
        <span id="subdivisionDot"></span>
    </div>
</div>

<!-- Tone Generator -->
<div class="box" id="toneBox">
    <h3>Tone generator</h3>
    <label for="waveform" style="margin-right:6px;">Waveform:</label>
    <select id="waveform">
        <option value="square">Square</option>
        <option value="sine">Sine</option>
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
    </select>
    <button id="playTone" style="margin-left:8px;">Play</button>
    <button id="stopTone">Stop</button>
    <div style="display:flex;align-items:center;gap:8px;position:relative;">
        <button id="decrementNote">â—€</button>

        <div class="sliderWrapper" style="position:relative;display:inline-block;">
            <input id="noteDial" type="range" min="0" max="60" value="30">
            <!-- notch marker -->
            <div class="sliderNotch"></div>
        </div>

        <button id="incrementNote">â–¶</button>
    </div>
    <div id="dialNote">Note: --</div>
    <div id="dialFreq">Freq: -- Hz</div>
    <div>
        <canvas id="toneWave" style="height: 50px;"></canvas>
    </div>
</div>

<!-- Tuner -->
<div class="box" id="tunerBox">
    <h3>Tuner</h3>
    <div class="metric" id="note">--</div>
    <div id="freq" class="sub">-- Hz</div>
    <div id="cents" class="sub">-- cents</div>
    <div class="needle"><div id="needleIndicator"></div></div>
    <div class="status" id="status">Mic: initializing...</div>
</div>

<!-- Presets -->
<div class="box" id="presetsBox" style="display:none;">
    <h3>Presets</h3>
    <div>
        <button id="savePreset">Save Current Preset</button>
        <select id="presetSelect"></select>
        <button id="loadPreset">Load Preset</button>
        <button id="deletePreset">Delete Preset</button>
    </div>
</div>

<!-- About -->
<div class="box" id="aboutBox">
    <h3>About</h3>
    <p>It's a metronome and tuner! Send feedback to myagi.developer[@]gmail.com</p>
</div>

<script>
    // UI refs
    const noteElem = document.getElementById("note");
    const freqElem = document.getElementById("freq");
    const centsElem = document.getElementById("cents");
    const needleIndicator = document.getElementById("needleIndicator");
    const statusElem = document.getElementById("status");
    const toneBox = document.getElementById("toneBox");
    const metronomeBox = document.getElementById("metronomeBox");
    const tunerBox = document.getElementById("tunerBox");
    const playToneButton = document.getElementById("playTone");
    const stopToneButton = document.getElementById("stopTone");
    const waveform = document.getElementById("waveform");
    const decrementNote = document.getElementById("decrementNote");
    const incrementNote = document.getElementById("incrementNote");
    const noteDial = document.getElementById("noteDial");
    const tempo = document.getElementById("tempo");
    const subdivisions = document.getElementById("subdivisions");
    const clickSound = document.getElementById("clickSound");
    const startMetronomeButton = document.getElementById("startMetronome");
    const stopMetronomeButton = document.getElementById("stopMetronome");

    const NOTE_STRINGS = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

    // Audio + analyser
    let audioCtx = null;
    let analyser = null;
    let yinBuffer = null;
    let toneEnabled = true;
    let tunerEnabled = true;
    let metronomeBoxEnabled = true;

    const toneWaveCanvas = document.getElementById("toneWave");
    const ctx = toneWaveCanvas.getContext("2d");
    let waveAnimation = null;
    let waveFreq = 440; // current tone frequency

    function setElementState(id, enabled) {
        document.getElementById(id).disabled = !enabled;
    }

    // Tuner control
    function setTunerActive(active) {
        tunerEnabled = active;
        tunerBox.classList.toggle("dimmed", !active);
    }

    // Tone control
    function setToneActive(active) {
        toneEnabled = active;
        toneBox.classList.toggle("dimmed", !active);

        playToneButton.disabled = !active;
        stopToneButton.disabled = !active;
        waveform.disabled = !active;
        decrementNote.disabled = !active;
        incrementNote.disabled = !active;
        noteDial.disabled = !active;
    }

    function setMetronomeActive(active) {
        metronomeBoxEnabled = active;
        metronomeBox.classList.toggle("dimmed", !active);

        tempo.disabled = !active;
        startMetronomeButton.disabled = !active;
        stopMetronomeButton.disabled = !active;
        subdivisions.disabled = !active;
        clickSound.disabled = !active;
    }

    // Pitch mapping
    function freqToNoteData(freq) {
        const A4 = 440;
        const n = 12 * Math.log2(freq / A4);
        const nearest = Math.round(n);
        const idx = nearest + 57; // C0 offset
        const octave = Math.floor(idx / 12);
        const name = NOTE_STRINGS[((idx % 12) + 12) % 12];
        const target = A4 * Math.pow(2, nearest / 12);
        const cents = 1200 * Math.log2(freq / target);
        return { name, octave, cents };
    }

    // YIN (compact)
    function yinPitch(buf, sampleRate, threshold = 0.18, minFreq = 50, maxFreq = 1200) {
        const N = buf.length;
        const tauMin = Math.max(2, Math.floor(sampleRate / maxFreq));
        const tauMax = Math.min(N - 3, Math.floor(sampleRate / minFreq));
        if (tauMax <= tauMin) return null;

        const d = new Float32Array(tauMax + 1);
        for (let tau = 1; tau <= tauMax; tau++) {
            let sum = 0;
            for (let i = 0; i < N - tau; i++) {
                const diff = buf[i] - buf[i + tau];
                sum += diff * diff;
            }
            d[tau] = sum;
        }

        const cmnd = new Float32Array(tauMax + 1);
        cmnd[0] = 1;
        let running = 0;
        for (let tau = 1; tau <= tauMax; tau++) {
            running += d[tau];
            cmnd[tau] = d[tau] / (running / tau);
        }

        let tau = -1;
        for (let t = tauMin; t <= tauMax; t++) {
            if (cmnd[t] < threshold) {
                tau = t;
                while (t + 1 <= tauMax && cmnd[t + 1] < cmnd[t]) { t++; tau = t; }
                break;
            }
        }
        if (tau === -1) return null;

        const tauL = Math.max(1, tau - 1);
        const tauR = Math.min(tauMax, tau + 1);
        const denom = cmnd[tauR] + cmnd[tauL] - 2 * cmnd[tau];
        const delta = denom !== 0 ? 0.5 * (cmnd[tauL] - cmnd[tauR]) / denom : 0;
        const refinedTau = tau + delta;

        const freq = sampleRate / refinedTau;
        return (freq >= minFreq && freq <= maxFreq) ? freq : null;
    }

    // Tuner loop
    function drawSineWave(phase) {
        const w = toneWaveCanvas.width;
        const h = toneWaveCanvas.height;
        ctx.clearRect(0, 0, w, h);

        ctx.beginPath();
        ctx.moveTo(0, h/2);

        const amplitude = h/3;

        // ðŸ”§ cycles across canvas proportional to frequency
        const cyclesAcross = waveFreq / 100; // adjust divisor to scale nicely
        const k = (2 * Math.PI * cyclesAcross) / w;

        for (let x = 0; x <= w; x++) {
            const y = h/2 + amplitude * Math.sin(k * x + phase);
            ctx.lineTo(x, y);
        }

        ctx.strokeStyle = "#0077ff";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function startWaveAnimation(freq) {
        waveFreq = freq;
        wavePhase = 0;

        function animate() {
            wavePhase += 0.05; // constant animation speed
            drawSineWave(wavePhase);
            waveAnimation = requestAnimationFrame(animate);
        }
        animate();
    }

    function stopWaveAnimation() {
        if (waveAnimation) cancelAnimationFrame(waveAnimation);
        ctx.clearRect(0, 0, toneWaveCanvas.width, toneWaveCanvas.height);
    }

    // Tuner loop
    function startLoop() {
        let lastNote = "--";
        let lastFreq = "-- Hz";
        let lastCents = "-- cents";

        function update() {
            if (tunerEnabled && analyser) {
                analyser.getFloatTimeDomainData(yinBuffer);
                const f = yinPitch(yinBuffer, audioCtx.sampleRate);
                if (f && isFinite(f)) {
                    const { name, octave, cents } = freqToNoteData(f);
                    lastNote = `${name}${octave}`;
                    lastFreq = `${f.toFixed(2)} Hz`;
                    lastCents = `${cents > 0 ? "+" : ""}${cents.toFixed(1)} cents`;

                    // noteElem.textContent = `${name}${octave}`;
                    // freqElem.textContent = `${f.toFixed(2)} Hz`;
                    // centsElem.textContent = `${cents > 0 ? "+" : ""}${cents.toFixed(1)} cents`;
                    
                    noteElem.textContent = lastNote;
                    freqElem.textContent = lastFreq;
                    centsElem.textContent = lastCents;

                    const clamped = Math.max(-100, Math.min(100, cents));
                    const offsetPx = (clamped / 200) * 320;
                    needleIndicator.style.left = `calc(50% + ${offsetPx}px)`;
                } else {
                    // noteElem.textContent = "--";
                    // freqElem.textContent = "-- Hz";
                    // centsElem.textContent = "-- cents";
                    // needleIndicator.style.left = "50%";
                    noteElem.textContent = lastNote;
                    freqElem.textContent = lastFreq;
                    centsElem.textContent = lastCents;
                }
            }
            requestAnimationFrame(update);
        }
        requestAnimationFrame(update);
    }

    // Init audio
    async function init() {
        try {
            statusElem.textContent = "Mic: requesting access...";
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
            });

            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 8192;
            analyser.minDecibels = -100;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.0;

            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(analyser);

            yinBuffer = new Float32Array(8192);

            statusElem.textContent = "Mic: ready";
            startLoop();
            updateDialDisplay();
        } catch (e) {
            statusElem.textContent = "Mic: permission denied or unavailable";
            console.error(e);
        }
    }

    // Tone generator
    let toneOscillator = null;
    let toneGain = null;

    function setPlayButtonState(enabled) {
        document.getElementById("playTone").disabled = !enabled;
    }

    function setPlayMetronomeButtonState(enabled) {
        document.getElementById("startMetronome").disabled = !enabled;
    }

    function dialToNote(index) {
        const A4 = 440;
        const semitoneOffset = index - 30;
        const f = A4 * Math.pow(2, semitoneOffset / 12);
        const n = 12 * Math.log2(f / A4);
        const nearest = Math.round(n);
        const noteIndex = nearest + 57;
        const octave = Math.floor(noteIndex / 12);
        const name = NOTE_STRINGS[((noteIndex % 12) + 12) % 12];
        return { name, octave, f };
    }

    function updateDialDisplay() {
        const idx = parseInt(document.getElementById("noteDial").value, 10);
        const { name, octave, f } = dialToNote(idx);
        document.getElementById("dialNote").textContent = `Note: ${name}${octave}`;
        document.getElementById("dialFreq").textContent = `Freq: ${f.toFixed(2)} Hz`;

        if (toneOscillator) {
            toneOscillator.frequency.setValueAtTime(f, audioCtx.currentTime);
            waveFreq = f; // ðŸ”§ update wavelength live
        }
    }

    function updateWaveform() {
        const wave = document.getElementById("waveform").value;
        if (toneOscillator) {
            toneOscillator.type = wave; // ðŸ”Š change waveform live
        }
    }

    function playTone(freq, type = "sine") {
        if (toneOscillator) return;

        toneOscillator = audioCtx.createOscillator();
        toneGain = audioCtx.createGain();

        toneOscillator.type = type;
        toneOscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

        toneGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        toneOscillator.connect(toneGain).connect(audioCtx.destination);
        toneOscillator.start();

        setPlayButtonState(false);
        setTunerActive(false);

        startWaveAnimation(freq);

        toneOscillator.onended = () => {
            toneOscillator = null;
            toneGain = null;
            setPlayButtonState(true);
            setTunerActive(true);
            stopWaveAnimation();
            updatePauseMessages();
        };

        updatePauseMessages();
    }

    function stopTone() {
        if (toneOscillator) {
            toneOscillator.stop();
            toneOscillator.disconnect();
            if (toneGain) toneGain.disconnect();
            toneOscillator = null;
            toneGain = null;
        }

        setPlayButtonState(true);
        setTunerActive(true);

        stopWaveAnimation();

        updatePauseMessages();
    }

    function changeDial(delta) {
        const dial = document.getElementById("noteDial");
        let val = parseInt(dial.value, 10);
        val = Math.max(parseInt(dial.min), Math.min(parseInt(dial.max), val + delta));
        dial.value = val;
        updateDialDisplay(); // reuse your existing function
    }

    // Metronome
    let metronomeInterval = null;
    let subdivisionInterval = null;
    let tapTimes = [];
    let tappingActive = false;
    let tapTimeout = null;

    function playClick(strong = true) {
        if (tappingActive) return;

        if (!audioCtx) audioCtx = new AudioContext();
        const now = audioCtx.currentTime;

        // read sound choice directly from dropdown
        const soundChoice = document.getElementById("clickSound")?.value || "square";

        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = soundChoice;
        osc.frequency.setValueAtTime(strong ? 1000 : 1500, now);
        gain.gain.setValueAtTime(strong ? 0.2 : 0.1, now);

        osc.connect(gain).connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.05);

        const dot = strong ? document.getElementById("metronomeDot")
            : document.getElementById("subdivisionDot");
        dot.style.opacity = 1;
        setTimeout(() => { dot.style.opacity = 0; }, 50);
    }

    function registerTap(e) {
        const ignoredIds = new Set(["startMetronome","stopMetronome","subdivisions","tempo","clickSound"]);
        if (ignoredIds.has(e.target.id)) return;
        e.preventDefault();

        const now = performance.now();
        tapTimes.push(now);
        if (tapTimes.length > 8) tapTimes.shift();

        // mark tapping active (mute ticks)
        tappingActive = true;

        if (tapTimes.length >= 2) {
            const lastInterval = tapTimes[tapTimes.length - 1] - tapTimes[tapTimes.length - 2];
            const bpm = Math.round(60000 / lastInterval);

            tempo.value = bpm;
            document.getElementById("metronomeText").textContent = `Tapped tempo: ${bpm} BPM`;
            startMetronome(); // keep scheduler running at new BPM
        }

        // reset timeout: if no tap for 1s, unmute ticks
        clearTimeout(tapTimeout);
        tapTimeout = setTimeout(() => {
            tappingActive = false;
        }, 1000);
    }

    function startMetronome() {
        let tempoValue = tempo.value;
        if (tempoValue <= 0) {
            tempoValue = "120";
            tempo.value = tempoValue;
        }
        const bpm = parseInt(tempoValue, 10);
        const subdivisions = parseInt(getSubdivisions(), 10);
        const beatMs = 60000 / bpm;
        const subMs = beatMs / subdivisions;

        // clear existing intervals
        stopMetronome();

        // main beat drives scheduling; subdivisions are timed off each beat
        metronomeInterval = setInterval(() => {
            // main beat (strong)
            playClick(true);

            // schedule subdivisions relative to this beat (no separate interval)
            if (subdivisions > 1) {
                for (let i = 1; i < subdivisions; i++) {
                    setTimeout(() => {
                    playClick(false);
                    }, i * subMs);
                }
            }
        }, beatMs);

        document.getElementById("metronomeText").textContent =
            `Playing at ${bpm} BPM (${subdivisions} subdivisions)`;
        setElementState("startMetronome", false);
        updatePauseMessages();
    }

    function stopMetronome() {
        if (metronomeInterval) clearInterval(metronomeInterval);
        if (subdivisionInterval) clearInterval(subdivisionInterval); // safe no-op now
        metronomeInterval = null;
        subdivisionInterval = null;

        document.getElementById("metronomeText").textContent = "Stopped";
        document.getElementById("metronomeDot").style.opacity = 0;
        document.getElementById("subdivisionDot").style.opacity = 0;
        setElementState("startMetronome", true);
        updatePauseMessages();
    }

    function getTempo() {
        const tempoField = document.getElementById("tempo");
        let bpm = parseInt(tempoField.value, 10);
        if (!bpm || bpm < 1) {
            bpm = 120; // default
            tempoField.value = bpm;
        }
        return bpm;
    }

    function getSubdivisions() {
        const subsField = document.getElementById("subdivisions");
        let subs = parseInt(subsField.value, 10);
        if (!subs || subs < 1) {
            subs = 1; // default
            subsField.value = subs;
        }
        return subs;
    }

    function updatePauseMessages() {
        if (toneOscillator) {
            statusElem.textContent = "Tuner paused while tone is playing.";
        } else if (metronomeInterval) {
            statusElem.textContent = "Tuner paused while metronome is on.";
        } else {
            statusElem.textContent = "Mic: ready";
        }
    }

    // Presets
    function initPresets() {
        if (typeof(Storage) === "undefined") {
            // localStorage not available
            return;
        }
        document.getElementById("presetsBox").style.display = "block";
        refreshPresetList();
    }

    function savePreset() {
        const bpm = getTempo();
        const subdivisions = getSubdivisions();
        const noteDialVal = document.getElementById("noteDial").value;
        const waveformVal = document.getElementById("waveform").value;
        const clickSoundVal = document.getElementById("clickSound").value; // NEW

        const preset = { bpm, subdivisions, noteDialVal, waveformVal, clickSoundVal };
        const name = prompt("Preset name:");
        if (!name) return;

        localStorage.setItem("preset_" + name, JSON.stringify(preset));
        refreshPresetList();
    }

    function loadPreset() {
        const select = document.getElementById("presetSelect");
        const key = select.value;
        if (!key) return;

        const preset = JSON.parse(localStorage.getItem(key));
        if (!preset) return;

        document.getElementById("tempo").value = preset.bpm;
        document.getElementById("subdivisions").value = preset.subdivisions;
        document.getElementById("noteDial").value = preset.noteDialVal;
        document.getElementById("waveform").value = preset.waveformVal;
        if (preset.clickSoundVal) {
            document.getElementById("clickSound").value = preset.clickSoundVal; // NEW
        }

        updateDialDisplay();
        updateWaveform();
    }

    function deletePreset() {
        const select = document.getElementById("presetSelect");
        const key = select.value;
        if (!key) return;

        localStorage.removeItem(key);
        refreshPresetList();
    }

    function refreshPresetList() {
        const select = document.getElementById("presetSelect");
        select.innerHTML = "";

        let hasPresets = false;
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.startsWith("preset_")) {
                const opt = document.createElement("option");
                opt.value = key;
                opt.textContent = key.replace("preset_", "");
                select.appendChild(opt);
                hasPresets = true;
            }
        }

        // Show/hide dropdown + load/delete buttons depending on content
        select.style.display = hasPresets ? "inline-block" : "none";
        document.getElementById("loadPreset").style.display = hasPresets ? "inline-block" : "none";
        document.getElementById("deletePreset").style.display = hasPresets ? "inline-block" : "none";
    }

    // Initialize presets box on page load
    initPresets();

    // Events
    // Presets
    document.getElementById("savePreset").addEventListener("click", savePreset);
    document.getElementById("loadPreset").addEventListener("click", loadPreset);
    document.getElementById("deletePreset").addEventListener("click", deletePreset);

    metronomeBox.addEventListener("pointerdown", (e) => {
        if (metronomeInterval || (metronomeBoxEnabled && tapTimes.length < 2) || (metronomeBoxEnabled && toneEnabled)) {
            stopTone();
            setTunerActive(false);
            setToneActive(false);
            registerTap(e);
        }
    });

    document.getElementById("startMetronome").addEventListener("click", () => {
        stopTone();
        setTunerActive(false);
        setToneActive(false);
        setMetronomeActive(true);
        startMetronome();
    });
    document.getElementById("stopMetronome").addEventListener("click", () => {
        stopMetronome();
        setTunerActive(true);
        setToneActive(true);
        setMetronomeActive(false);
    });
    document.getElementById("tempo").addEventListener("input", () => {
        if (metronomeInterval) {
            setTunerActive(false);
            setToneActive(false);
            setMetronomeActive(true);
            startMetronome(); // restart with new BPM
        }
    });
    document.getElementById("subdivisions").addEventListener("change", () => {
        if (metronomeInterval) {
            // If the metronome is already running, restart immediately with new subdivision
            setTunerActive(false);
            setToneActive(false);
            setMetronomeActive(true);
            startMetronome();
        }
    });

    document.getElementById("decrementNote").addEventListener("click", () => {
        setTunerActive(false);
        setMetronomeActive(false);
        changeDial(-1);
    });
    document.getElementById("incrementNote").addEventListener("click", () => {
        setTunerActive(false);
        setMetronomeActive(false);
        changeDial(1);
    });

    document.getElementById("noteDial").addEventListener("input", () => {
        setTunerActive(false);
        setMetronomeActive(false);
        updateDialDisplay();
    });
    document.getElementById("waveform").addEventListener("change", () => {
        setTunerActive(false);
        setMetronomeActive(false);
        updateWaveform();
    });
    document.getElementById("playTone").addEventListener("click", () => {
        setTunerActive(false);
        setMetronomeActive(false);
        const idx = parseInt(document.getElementById("noteDial").value, 10);
        const { f } = dialToNote(idx);
        const wave = document.getElementById("waveform").value;
        playTone(f, wave);
        updatePauseMessages();
    });
    document.getElementById("stopTone").addEventListener("click", () => {
        setTunerActive(true);
        setMetronomeActive(true);
        stopTone();
        updatePauseMessages();
    });

    document.addEventListener("keydown", (e) => {
        if (e.code === "Space") { // Start/stop metronome or tone generator
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                if (toneOscillator) {
                    setTunerActive(true);
                    setMetronomeActive(true);
                    stopTone();
                    updatePauseMessages();
                } else {
                    setTunerActive(false);
                    setMetronomeActive(false);
                    const idx = parseInt(document.getElementById("noteDial").value, 10);
                    const { f } = dialToNote(idx);
                    const wave = document.getElementById("waveform").value;
                    playTone(f, wave);
                    updatePauseMessages();
                }
            } else if (metronomeBoxEnabled) {
                if (metronomeInterval) {
                    stopMetronome();
                    setTunerActive(true);
                    setToneActive(true);
                    setPlayMetronomeButtonState(true);
                } else {
                    stopTone();
                    setTunerActive(false);
                    setToneActive(false);
                    startMetronome();
                    setPlayMetronomeButtonState(false);
                }
            }
        } else if (e.code === "ArrowRight") { // Higher tone
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(1);
            }
        } else if (e.code === "ArrowLeft") { // Lower tone
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(-1);
            }
        } else if (e.code === "KeyD") { // Higher tone
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(1);
            }
        } else if (e.code === "KeyA") { // Lower tone
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(-1);
            }
        } else if (e.code === "KeyE") { // Change waveform
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                const waveformSelect = document.getElementById("waveform");
                const options = Array.from(waveformSelect.options);
                let idx = waveformSelect.selectedIndex;
                idx = (idx - 1 + options.length) % options.length;
                waveformSelect.selectedIndex = idx;
                updateWaveform(); // reuse your existing function
            }
        } else if (e.code === "KeyQ") { // Change waveform
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                const waveformSelect = document.getElementById("waveform");
                const options = Array.from(waveformSelect.options);
                let idx = waveformSelect.selectedIndex;
                idx = (idx + 1) % options.length;
                waveformSelect.selectedIndex = idx;
                updateWaveform();
            }
        } else if (e.code === "ShiftLeft" || e.code === "ShiftRight") { // Reset tone to A4
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                const dial = document.getElementById("noteDial");
                // A4 is the center reference (index 30 in your mapping)
                dial.value = 30;
                updateDialDisplay();

                // If tone is playing, reset its frequency immediately
                const { f } = dialToNote(30);
                if (toneOscillator) {
                    toneOscillator.frequency.setValueAtTime(f, audioCtx.currentTime);
                }
            } else if (metronomeBoxEnabled) {
                const bpm = 120;
                const intervalMs = 60000 / bpm;

                if (metronomeInterval) clearInterval(metronomeInterval); 

                // drive both click + blink from the same interval
                metronomeInterval = setInterval(() => {
                    playClick();
                }, intervalMs);

                document.getElementById("tempo").value = bpm;
                document.getElementById("metronomeText").textContent = `Playing at ${bpm} BPM`;
                updatePauseMessages();
            }
        } else if (e.code === "ArrowUp") { // Increase tempo
             if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.min(240, bpm + 1); // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing at ${bpm} BPM`;
                if (metronomeInterval) {
                    startMetronome(); // restart with new BPM
                }
            }
        } else if (e.code === "ArrowDown") { // Decrease tempo
             if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.max(30, bpm - 1); // floor at 30 // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing at ${bpm} BPM`;
                if (metronomeInterval) {
                    startMetronome(); // restart with new BPM
                }
            }
        } else if (e.code === "KeyW") { // Increase tempo
             if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.min(240, bpm + 1); // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing at ${bpm} BPM`;
                startMetronome();
            }
        } else if (e.code === "KeyS") { // Decrease tempo
            if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.max(30, bpm - 1); // floor at 30 // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing at ${bpm} BPM`;
                startMetronome();
            }
        }
    });

    // Initialize dial display
    updateDialDisplay();
    init();
</script>
</body>
</html>
