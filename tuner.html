<!DOCTYPE html>
<html lang="en">

<!-- Copyright (C) 2025 Michael Yagi -->
<!-- This program is free software: you can redistribute it and/or modify -->
<!-- it under the terms of the GNU General Public License as published by -->
<!-- the Free Software Foundation, either version 3 of the License, or -->
<!-- (at your option) any later version. -->
<!-- This program is distributed in the hope that it will be useful, -->
<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- GNU General Public License for more details. -->
<!-- You should have received a copy of the GNU General Public License -->
<!-- along with this program.  If not, see <https://www.gnu.org/licenses/>. -->

<head>
    <meta charset="UTF-8">
    <title>Open Source Metronome | Subdivisions, Polyrhythms, Tone Generator, Tuner, Presets</title>
    <meta name="description" content="The best open source, ad-free premium metronome. Includes subdivisions, polyrhythms, tone generator, tuner, and preset saving for musicians.">
    <meta name="keywords" content="metronome, open source metronome, premium metronome, ad-free metronome, metronome with subdivisions, polyrhythms, tone generator, tuner, presets, musician practice tool, classical music, violin, viola, cello, bass, wind instruments, brass, html, javascript">
    <meta name="robots" content="index, follow">
    <meta name="author" content="Michael Yagi">
    <link rel="icon" type="image/x-icon" href="./images/favicon.ico">
    <link rel="canonical" href="https://michaelyagi.github.io/tuner.html">
    <meta property="og:title" content="Premium Open Source Metronome">
    <meta property="og:description" content="Ad-free metronome with subdivisions, polyrhythms, tone generator, tuner, and presets.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://michaelyagi.github.io/tuner.html">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* --- Theme Variables --- */
        :root {
            --page-bg-color: #111;       /* Page Background Color */
            --box-bg-color: #111;        /* Box Background Color */
            --box-header-color: #ff6600; /* Box Header Font Color */
            --input-font-color: #ffcc00; /* Input Font Color */
            --input-bg-color: #0b1d3a;   /* Input Background Color */
            --wave-color: #0077ff;       /* Tone Generator Wave Color */
            --text-color: #eee;          /* General Font Color */
            --accent-color: #ff6600;     /* Swatch Select Outline Color */
            --status-color: #666;        /* adaptive - tuner status */
            --sub-color: #666;           /* adaptive */
        }
        .theme-default {
            --page-bg-color: #111;
            --box-bg-color: #111;
            --box-header-color: #ff6600;
            --input-font-color: #ffcc00;
            --input-bg-color: #0b1d3a;
            --wave-color: #0077ff;
            --text-color: #eee;
            --accent-color: #ff6600;
        }
        .theme-optimus {
            --page-bg-color: #D92121;
            --box-bg-color: #0047AB;
            --box-header-color: #D3D3D3;
            --input-font-color: #111111;
            --input-bg-color: #ffcc00;
            --wave-color: #4682BF;
            --text-color: #D3D3D3;
            --accent-color: #e63946;
        }
        .theme-cotton-candy {
            --page-bg-color: #e63946;
            --box-bg-color: #1d3557;
            --box-header-color: #a8dadc;
            --input-bg-color: #457b9d;
            --input-font-color: #f1faee;
            --wave-color: #fafe0b;
            --text-color: #f1faee;
            --accent-color: #e65100;
        }
        .theme-korg-blue {
            --page-bg-color: #0a0f1c;
            --box-bg-color: #111a33;
            --box-header-color: #00aaff;
            --input-bg-color: #0d223d;
            --input-font-color: #66ccff;
            --wave-color: #0077ff;
            --text-color: #e0e6ff;
            --accent-color: #00aaff;
        }
        .theme-korg-silver {
            --page-bg-color: #d9d9d9;
            --box-bg-color: #f0f0f0;
            --box-header-color: #ff6600;
            --input-bg-color: #cccccc;
            --input-font-color: #222;
            --wave-color: #0077ff;
            --text-color: #111;
            --accent-color: #ff6600;
        }
        .theme-korg-green {
            --page-bg-color: #1a2b1a;
            --box-bg-color: #2d402d;
            --box-header-color: #ffcc00;
            --input-bg-color: #334d33;
            --input-font-color: #ccffcc;
            --wave-color: #0077ff;
            --text-color: #e6ffe6;
            --accent-color: #ffcc00;
        }
        /* Reset body margins and prevent horizontal scroll */
        html, body {
            margin: 0;              /* remove default white margin */
            padding: 0;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;     /* stop sideways scrolling */
        }
        body {
            font-family: system-ui, sans-serif;
            margin: 0;          /* no external margin */
            padding-top: 20px;
            background-color: var(--page-bg-color);
            color: var(--text-color);
        }
        h1 { margin-bottom: 12px; }
        h3 { margin-top: 0; }
        .box {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 20px;
        }
        label { font-weight: 600; }
        .metric { font-size: 2rem; }
        .sub {
            color: var(--sub-color);
        }
        .needle { width: 100%; height: 10px; background: #eee; border-radius: 6px; position: relative; margin-top: 8px; }
        .needle > div { position: absolute; top: -6px; width: 2px; height: 22px; background: #333; left: 50%; transition: left 80ms linear; }
        .status {
            color: var(--status-color);
            font-size: 0.95rem;
            margin-top: 8px;
        }
        .dimmed { opacity: 0.4; }
        #noteDial { width: 100%; box-sizing: border-box; }
        #tempo { width: 100%; box-sizing: border-box; }
        /* Blinking red dot */
        #metronomeDot {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 8px;
            margin-bottom: 5px;
            border-radius: 50%;
            background-color: red;
            border: 1px solid black;
            opacity: 0; /* hidden until pulse */
            vertical-align: middle;
            transition: opacity 0.1s ease;
        }

        #subdivisionDot {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 6px;
            margin-bottom: 5px;
            border-radius: 50%;
            background-color: blue; /* distinct color */
            border: 1px solid black;
            opacity: 0;
            vertical-align: middle;
            transition: opacity 0.1s ease;
        }

        #polyDot {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 6px;
            margin-bottom: 5px;
            border-radius: 50%;
            background-color: green; /* distinct color */
            border: 1px solid black;
            opacity: 0;
            vertical-align: middle;
            transition: opacity 0.1s ease;
        }

        #visualDots {
            margin-left: -7px;
            margin-top: 10px;
        }
        /* Animated wave */
        #micToggle {
            margin-top: 10px;
        }
        #toneWave {
            /* border: 1px solid #ddd; */
            margin-top: 12px;
            width: 100%;
        }
        #metronomeBox {
            user-select: none; /* prevent text highlight */
        }
        #presetsBox select, #presetsBox button {
            padding: 2px 4px;
            font-size: 0.85rem;
            height: 22px;
        }
        .sliderWrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .sliderNotch {
            position: absolute;
            top: 100%;
            left: 50.5%;              /* middle of the slider */
            width: 2px;
            height: 5px;
            background: var(--sub-color);      /* notch color */
            transform: translate(-50%, -50%);
            cursor: pointer;
        }
        .tempoSliderNotch {
            position: absolute;
            top: 100%;
            left: 43.5%;              /* middle of the slider */
            width: 2px;
            height: 5px;
            background: var(--sub-color);      /* notch color */
            transform: translate(-50%, -50%);
            cursor: pointer;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
        }

        .col {
            flex: 0.4;
            padding: 4px 8px;
        }

        .col label {
            font-weight: 600;
            display: block;
        }

        .col input[type="color"] {
            width: 44px;
            height: 28px;
            border: none;
            cursor: pointer;
        }

        /* --- Korg inspired overrides --- */
        .box {
            background: var(--box-bg-color);
            color: var(--text-color);
            border: 2px solid #333;
            border-radius: 12px;
            width: 100%;             /* fill available width */
            max-width: 500px;        /* larger cap on bigger screens */
            margin: 0 auto 24px;     /* center horizontally with more spacing */
            padding: 20px;           /* add inner breathing room */
            box-sizing: border-box;  /* include padding in width */
        }
        .box h3 {
            text-align: center;
            color: var(--box-header-color);
            margin-bottom: 16px;
        }
        .box input[type=number],
        .box input[type=text],
        .box select {
            background: var(--input-bg-color);
            color: var(--input-font-color);
            border: none;
            font-size: 1rem;
            text-align: center;
            border-radius: 4px;
            padding: 2px 4px;
        }
        .box button {
            background: #222;
            color: #eee;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .box button:hover { background: #333; }
        pre.box.code {
            position: relative;
            padding: 10px;
        }
        .box > .copy-btn {
            display: block;       /* puts button on its own line */
            margin-bottom: 10px;  /* creates space below button */
            font-size: 12px;
            cursor: pointer;
        }
        #themeSwatches {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 tiles per row */
            gap: 12px;                              /* spacing between tiles */
            margin-top: 16px;
        }

        .theme-swatch {
            display: flex;
            justify-content: space-between;         /* keep gaps between color blocks */
            align-items: center;
            padding: 8px;                           /* smaller padding so they fit */
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: border 0.2s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .swatch {
            flex: 1;
            aspect-ratio: 1 / 1;                    /* force square shape */
            margin: 0 4px;                          /* spacing between blocks */
            border-radius: 6px;
            border: 1px solid #444;
            max-width: 60px;                        /* cap width so they fit inside 500px box */
        }

        .theme-swatch.selected {
            border-color: var(--accent-color);
        }

        .theme-swatch .page-bg {
            background: var(--page-bg-color);
        }
        .theme-swatch .box-bg {
            background: var(--box-bg-color);
        }
        .theme-swatch .box-header {
            background: var(--box-header-color);
        }

        /* Custom theme row */
        #customThemeRow {
            display: flex;
            flex-direction: column; /* stacked inputs */
            margin-top: 16px;
        }

        .theme-swatch[data-theme="custom"] {
            justify-content: unset;   /* remove spacing */
            gap: 6px;                 /* small consistent gap between squares */
        }

        .theme-text {
            margin-top: 40px;
            margin-left: 10px;
        }
    </style>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V9XXZTGS4W"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-V9XXZTGS4W');
    </script>
</head>
<body>

<!-- Metronome -->
<div class="box" id="metronomeBox">
    <h3>Metronome</h3>
    <label for="clickSound">Click Sound:</label>
    <select id="clickSound">
        <option value="square">Square</option>
        <option value="sine">Sine</option>
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="hihat">Hi-Hat</option>
        <option value="kick">Kick</option>
        <option value="snare">Snare</option>
        <option value="clap">Clap</option>
    </select>
    <button id="startMetronome" style="margin-left:8px;">Start</button>
    <button id="stopMetronome">Stop</button>
    <div style="display:flex;align-items:center;gap:8px;position:relative;">
        <button id="decrementTempo">◀</button>

        <div class="sliderWrapper" style="position:relative;display:inline-block;">
            <input id="tempo" type="range" min="30" max="240" value="120">
            <!-- notch marker -->
            <div id="tempoSliderNotch" class="tempoSliderNotch sub"></div>
        </div>

        <button id="incrementTempo">▶</button>
    </div>

    <div>
        <label for="subdivisions">Subdivisions:</label>
        <select id="subdivisions" style="margin-right: 15px;">
            <option value="0">None</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
        </select>
        <label for="polySubdivisions">Polyrhythm:</label>
        <select id="polySubdivisions">
            <option value="0">None</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
        </select>
    </div>

    <div id="dialBPM">BPM: --</div>

    <div id="metronomeStatus" class="status">
        <span id="metronomeText">&nbsp;</span>
    </div>

    <div id="visualDots">
        <span id="metronomeDot"></span>
        <span id="subdivisionDot"></span>
        <span id="polyDot"></span>
    </div>
</div>

<!-- Tone Generator -->
<div class="box" id="toneBox">
    <h3>Tone generator</h3>
    <label for="waveform" style="margin-right:6px;">Waveform:</label>
    <select id="waveform">
        <option value="square">Square</option>
        <option value="sine">Sine</option>
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="electricGuitar">Electric Guitar</option>
        <option value="acousticGuitar">Acoustic Guitar</option>
    </select>
    <button id="playTone" style="margin-left:8px;">Play</button>
    <button id="stopTone">Stop</button>
    <div style="display:flex;align-items:center;gap:8px;position:relative;">
        <button id="decrementNote">◀</button>

        <div class="sliderWrapper" style="position:relative;display:inline-block;">
            <input id="noteDial" type="range" min="0" max="60" value="30">
            <!-- notch marker -->
            <div id="sliderNotch" class="sliderNotch sub"></div>
        </div>

        <button id="incrementNote">▶</button>
    </div>
    <div id="dialNote">Note: --</div>
    <div id="dialFreq">Freq: -- Hz</div>
    <div>
        <canvas id="toneWave" style="height: 50px;"></canvas>
    </div>
</div>

<!-- Tuner -->
<div class="box" id="tunerBox">
    <h3>Tuner</h3>
    <div class="metric" id="note">--</div>
    <div id="freq" class="sub">-- Hz</div>
    <div id="cents" class="sub">-- cents</div>
    <button id="micToggle" style="display: none;">Disable Mic</button>
    <div class="needle"><div id="needleIndicator"></div></div>
    <div class="status" id="status">Mic: initializing...</div>
</div>

<!-- Presets -->
<div class="box" id="presetsBox" style="display:none;">
    <h3>Presets</h3>
    <div>
        <button id="savePreset">Save Current Preset</button>
        <select id="presetSelect"></select>
        <button id="loadPreset">Load Preset</button>
        <button id="deletePreset">Delete Preset</button>
    </div>
</div>

<!-- Themes -->
<div id="themePicker" class="box">
    <h3>Themes</h3>

    <!-- Predefined themes side by side -->
    <div id="themeSwatches">
        <div class="theme-swatch theme-default" data-theme="default" title="Korg TM-60">
            <div class="swatch page-bg"></div>
            <div class="swatch box-bg"></div>
            <div class="swatch box-header"></div>
        </div>
        <div class="theme-swatch theme-korg-blue" data-theme="korg-blue" title="Korg MA-2">
            <div class="swatch page-bg"></div>
            <div class="swatch box-bg"></div>
            <div class="swatch box-header"></div>
        </div>
        <div class="theme-swatch theme-korg-silver" data-theme="korg-silver" title="Korg Kross 2">
            <div class="swatch page-bg"></div>
            <div class="swatch box-bg"></div>
            <div class="swatch box-header"></div>
        </div>
        <div class="theme-swatch theme-korg-green" data-theme="korg-green" title="Korg MS-20">
            <div class="swatch page-bg"></div>
            <div class="swatch box-bg"></div>
            <div class="swatch box-header"></div>
        </div>
        <div class="theme-swatch theme-optimus" data-theme="optimus" title="Optimus Prime">
            <div class="swatch page-bg"></div>
            <div class="swatch box-bg"></div>
            <div class="swatch box-header"></div>
        </div>
        <div class="theme-swatch theme-cotton-candy" data-theme="cotton-candy" title="Cotton Candy">
            <div class="swatch page-bg"></div>
            <div class="swatch box-bg"></div>
            <div class="swatch box-header"></div>
        </div>
    </div>

    <!-- Custom theme row -->
    <div id="customThemeRow">
        <div class="theme-swatch" data-theme="custom" title="Custom">
            <div class="swatch" style="background:#ccc;"></div>
            <div class="swatch" style="background:#999;"></div>
            <div class="swatch" style="background:#666;"></div>
        </div>

        <div id="customThemeInputs" class="form-rows" style="display: none;">
            <div class="row">
                <div class="col">
                    <label for="customPageBg">Page Background:</label>
                </div>
                <div class="col">
                    <input type="color" id="customPageBg">
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label for="customBoxBg">Box Background:</label>
                </div>
                <div class="col">
                    <input type="color" id="customBoxBg">
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label for="customBoxHeader">Box Header:</label>
                </div>
                <div class="col">
                    <input type="color" id="customBoxHeader" value="#FFFFFF">
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label for="customInputBg">Input Background:</label>
                </div>
                <div class="col">
                    <input type="color" id="customInputBg">
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label for="customInputFont">Input Font:</label>
                </div>
                <div class="col">
                    <input type="color" id="customInputFont">
                </div>
            </div>

            <div class="row">
                <div class="col">
                    <label for="customWaveColor">Wave Color:</label>
                </div>
                <div class="col">
                    <input type="color" id="customWaveColor">
                </div>
            </div>
        </div>
    </div>
</div>

<!-- About -->
<div class="box" id="aboutBox">
    <h3>About</h3>
    <p>It's a metronome and tuner! Works offline. Accept microphone permissions to use the tuner. Tap the metronome box to capture BPM.</p>
    <p>Send feedback to myagi.developer[@]gmail.com</p>

    <div id="aboutExtras" style="display: none;">
        <p>Keyboard inputs:</p>
        <ul>
            <li>Spacebar - play tone</li>
            <li>e/q - Change waveform</li>
            <li>Right/d - increase pitch</li>
            <li>Left/a - decrease pitch</li>
            <li>Up/w - Increase tempo</li>
            <li>Down/s - Decrease tempo</li>
            <li>Shift - Reset pitch to A4</li>
        </ul>

        <hr>

        <p>Create tunes! Configure a simple beat and melody pattern. You can use a combination of hihats, claps, kicks, or snare.</p>

        <pre class="box code"><button class="copy-btn">Copy</button><code>
const beatPattern = [
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 },
    { type: "hihat", dur: 2 }
];

const melody = [
    { note: "A5", dur: 1 },
    { note: "rest", dur: 1 },
    { note: "G#5", dur: 1 },
    { note: "E5", dur: 1 },
    { note: "rest", dur: 1 },
    { note: "A5", dur: 1 },
    { note: "rest", dur: 1 },
    { note: "G#5", dur: 1 },
    { note: "rest", dur: 3 },
    { note: "E5", dur: 2 },
    { note: "E5", dur: 2 },
    { note: "D5", dur: 0.5 },
    { note: "rest", dur: 0.5 },
    { note: "D5", dur: 6 }
];

playBeat(beatPattern);
playMelody(melody);
        </code></pre>

        <p>Copy and paste everything in the console or <button id="playSimpleSong">Play</button> now!</p>

        <p>Experiment with chords or stacked beats. The shortest value determines when the sequence advances, and any longer notes or hits will continue sounding until their full duration completes.</p>

        <pre class="box code"><button class="copy-btn">Copy</button><code>
const melody = [
    { notes: [
        // This shortest note defines the step length;
        // the sequence advances after 1 beat
        { note: "B4", dur: 1 },
        // Sustains across the next 2 steps until
        // its full duration completes
        { note: "B5", dur: 3 },
        // Also sustains into the following step
        { note: "B2", dur: 2 }
    ]},
    // Instrument options:
    // sine,square,triangle,sawtooth
    // piano,strings,electricGuitar or acousticGuitar
    { note: "B3", dur: 1, instrument: "electricGuitar" },
    { note: "B3", dur: 1 },
    { note: "B3", dur: 1 }
];
const beatPattern = [
    { types: [
        { type: "kick", dur: 2 },
        // Sustains across the next step until
        // its full duration completes
        { type: "snare", dur: 2 },
        // This shortest beat defines the step length
        { type: "hihat", dur: 1 },
    ]},
    { type: "hihat", dur: 1 },
    { type: "hihat", dur: 1 }
];
        </code></pre>

        <p><button id="playSong">Play</button> a version of the above that combines different chords and beat patterns.</p>

    </div>

    <a href="https://www.gnu.org/" target="_blank"><img src="./images/gplv3.png"></a>
</div>

<script>
    // UI refs
    const noteElem = document.getElementById("note");
    const freqElem = document.getElementById("freq");
    const centsElem = document.getElementById("cents");
    const needleIndicator = document.getElementById("needleIndicator");
    const statusElem = document.getElementById("status");
    const toneBox = document.getElementById("toneBox");
    const metronomeBox = document.getElementById("metronomeBox");
    const tunerBox = document.getElementById("tunerBox");
    const playToneButton = document.getElementById("playTone");
    const stopToneButton = document.getElementById("stopTone");
    const waveform = document.getElementById("waveform");
    const decrementNote = document.getElementById("decrementNote");
    const incrementNote = document.getElementById("incrementNote");
    const noteDial = document.getElementById("noteDial");
    const tempo = document.getElementById("tempo");
    const subdivisions = document.getElementById("subdivisions");
    const clickSound = document.getElementById("clickSound");
    const startMetronomeButton = document.getElementById("startMetronome");
    const stopMetronomeButton = document.getElementById("stopMetronome");
    const tempoUp = document.getElementById("incrementTempo");
    const tempoDown = document.getElementById("decrementTempo");

    const NOTE_STRINGS = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

    // Audio + analyser
    let analyser = null;
    let yinBuffer = null;
    let toneEnabled = true;
    let tunerEnabled = true;
    let metronomeBoxEnabled = true;

    const toneWaveCanvas = document.getElementById("toneWave");
    const ctx = toneWaveCanvas.getContext("2d");
    let waveAnimation = null;
    let waveFreq = 440; // current tone frequency
    let songPlaying = false;

    function isMobile() {
        let check = false;
        (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
        return check;
    }

    if (!isMobile()) {
        document.getElementById("aboutExtras").style.display = "block";
    }

    function setElementState(id, enabled) {
        document.getElementById(id).disabled = !enabled;
    }

    // Tuner control
    function setTunerActive(active) {
        tunerEnabled = active;
        tunerBox.classList.toggle("dimmed", !active);
    }

    // Tone control
    function setToneActive(active) {
        toneEnabled = active;
        toneBox.classList.toggle("dimmed", !active);

        playToneButton.disabled = !active;
        stopToneButton.disabled = !active;
        waveform.disabled = !active;
        decrementNote.disabled = !active;
        incrementNote.disabled = !active;
        noteDial.disabled = !active;
    }

    function setMetronomeActive(active) {
        metronomeBoxEnabled = active;
        metronomeBox.classList.toggle("dimmed", !active);

        tempo.disabled = !active;
        startMetronomeButton.disabled = !active;
        stopMetronomeButton.disabled = !active;
        subdivisions.disabled = !active;
        clickSound.disabled = !active;
    }

    // Pitch mapping
    function freqToNoteData(freq) {
        const A4 = 440;
        const n = 12 * Math.log2(freq / A4);
        const nearest = Math.round(n);
        const idx = nearest + 57; // C0 offset
        const octave = Math.floor(idx / 12);
        const name = NOTE_STRINGS[((idx % 12) + 12) % 12];
        const target = A4 * Math.pow(2, nearest / 12);
        const cents = 1200 * Math.log2(freq / target);
        return { name, octave, cents };
    }

    // YIN pitch - get the pitch from audio signal
    // http://github.com/patriceguyot/Yin/blob/master/yin.py
    function yinPitch(buf, sampleRate, threshold = 0.18, minFreq = 50, maxFreq = 1200) {
        const N = buf.length;
        // delay in samples - smallest lag allowed
        const tauMin = Math.max(2, Math.floor(sampleRate / maxFreq));
        // largest lag allowed
        const tauMax = Math.min(N - 3, Math.floor(sampleRate / minFreq));
        if (tauMax <= tauMin) return null;

        // For each lag tau, compute the squared difference between the signal and a delayed version of itself
        // if the signal repeats every (tau) lag samples, the difference will be small
        const d = new Float32Array(tauMax + 1);
        for (let tau = 1; tau <= tauMax; tau++) {
            let sum = 0;
            for (let i = 0; i < N - tau; i++) {
                const diff = buf[i] - buf[i + tau];
                sum += diff * diff;
            }
            d[tau] = sum;
        }

        // Cumulative Mean Normalized Difference
        // Normalizes the difference function so values are comparable across lags.
        // cmnd[tau] tends toward 1 if no periodicity, and drops below threshold if strong periodicity.
        // Key step - it makes the function robust to amplitude changes.
        // After normalization - the CMND step - small values drop below the threshold, which flags them as candidate pitches.
        // Else no periodicity detected - ignore
        const cmnd = new Float32Array(tauMax + 1);
        cmnd[0] = 1;
        let running = 0;
        for (let tau = 1; tau <= tauMax; tau++) {
            running += d[tau];
            cmnd[tau] = d[tau] / (running / tau);
        }

        // Scan for the first tau where cmnd[t] drops below the threshold - this indicates a likely fundamental period
        // the fundamental period corresponds to the time between successive cycles of the waveform
        let tau = -1;
        for (let t = tauMin; t <= tauMax; t++) {
            if (cmnd[t] < threshold) {
                tau = t;
                while (t + 1 <= tauMax && cmnd[t + 1] < cmnd[t]) { t++; tau = t; }
                break;
            }
        }
        if (tau === -1) return null;

        const tauL = Math.max(1, tau - 1);
        const tauR = Math.min(tauMax, tau + 1);
        const denom = cmnd[tauR] + cmnd[tauL] - 2 * cmnd[tau];
        const delta = denom !== 0 ? 0.5 * (cmnd[tauL] - cmnd[tauR]) / denom : 0;
        const refinedTau = tau + delta;

        const freq = sampleRate / refinedTau;
        // estimated fundamental frequency
        return (freq >= minFreq && freq <= maxFreq) ? freq : null;
    }

    function syncUIState() {
        const tonePlaying = !!toneOscillator;
        const metronomePlaying = !!metronomeInterval;

        if (tonePlaying) {
            setToneActive(true);
            setMetronomeActive(false);
            setTunerActive(false);
        } else if (metronomePlaying) {
            setMetronomeActive(true);
            setToneActive(false);
            setTunerActive(false);
        } else {
            setToneActive(true);
            setMetronomeActive(true);
            setTunerActive(true);
        }
    }

    // Tuner loop
    function drawSineWave(phase) {
        const w = toneWaveCanvas.width;
        const h = toneWaveCanvas.height;
        ctx.clearRect(0, 0, w, h);

        ctx.beginPath();
        ctx.moveTo(0, h/2);

        const amplitude = h/3;

        // cycles across canvas proportional to frequency
        const cyclesAcross = waveFreq / 100; // adjust divisor to scale nicely
        const k = (2 * Math.PI * cyclesAcross) / w;

        for (let x = 0; x <= w; x++) {
            const y = h/2 + amplitude * Math.sin(k * x + phase);
            ctx.lineTo(x, y);
        }

        let waveColor = "#0077ff";
        if (typeof(Storage) !== "undefined") {
            const theme = localStorage.getItem("theme");
            if (theme) {
                const classTheme = 'theme-' + theme;
                document.body.classList.add(classTheme);
                const element = document.querySelector('.'+classTheme);
                waveColor = getComputedStyle(element).getPropertyValue('--wave-color').trim();
            }
        }

        ctx.strokeStyle = waveColor;
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function startWaveAnimation(freq) {
        waveFreq = freq;
        let wavePhase = 0;

        function animate() {
            wavePhase += waveFreq / 2000; // constant animation speed
            drawSineWave(wavePhase);
            waveAnimation = requestAnimationFrame(animate);
        }
        animate();
    }

    function stopWaveAnimation() {
        if (waveAnimation) cancelAnimationFrame(waveAnimation);
        ctx.clearRect(0, 0, toneWaveCanvas.width, toneWaveCanvas.height);
    }

    // Tuner
    // Toggle mute/unmute
    document.getElementById("micToggle").addEventListener("click", async () => {
        if (micStream) {
            disableMic();
        } else {
            await enableMic();
        }
    });

    async function enableMic() {
        if (micStream || micRequestPending) return; // already active or pending
        micRequestPending = true;
        try {
            await initAudioContext();

            // micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            micStream = await navigator.mediaDevices.getUserMedia({
                audio: {echoCancellation: false, noiseSuppression: false, autoGainControl: false}
            });

            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 8192;
            yinBuffer = new Float32Array(analyser.fftSize);

            micSource = audioCtx.createMediaStreamSource(micStream);
            micSource.connect(analyser);

            document.getElementById("micToggle").textContent = "Disable Mic";
            document.getElementById("status").textContent = "Mic: enabled";
            localStorage.setItem("micEnabled", "true");
            updatePauseMessages();
            startLoop();
            updateDialDisplay();
        } catch (err) {
            console.warn(err);
            disableMic();
        } finally {
            micRequestPending = false;
        }
    }

    function disableMic() {
        if (micStream) {
            // Stop all tracks
            micStream.getTracks().forEach(track => track.stop());
            micStream = null;
        }
        if (analyser) {
            analyser.disconnect();
            analyser = null;
        }

        localStorage.setItem("micEnabled", "false");
        document.getElementById("micToggle").textContent = "Enable Mic";
        document.getElementById("status").textContent = "Mic: disabled";
        resetTunerUI();
        stopLoop();
    }

    function resetTunerUI() {
        noteElem.textContent = "--";
        freqElem.textContent = "-- Hz";
        centsElem.textContent = "-- cents";
        needleIndicator.style.left = "50%";
    }

    let loopId = null;

    function startLoop() {
        let lastNote = "--";
        let lastFreq = "-- Hz";
        let lastCents = "-- cents";

        function update() {
            if (analyser && yinBuffer && audioCtx && audioCtx.state === "running") {
                analyser.getFloatTimeDomainData(yinBuffer);
                const f = yinPitch(yinBuffer, audioCtx.sampleRate);
                if (f && isFinite(f)) {
                    const { name, octave, cents } = freqToNoteData(f);
                    lastNote = `${name}${octave}`;
                    lastFreq = `${f.toFixed(2)} Hz`;
                    lastCents = `${cents > 0 ? "+" : ""}${cents.toFixed(1)} cents`;

                    noteElem.textContent = lastNote;
                    freqElem.textContent = lastFreq;
                    centsElem.textContent = lastCents;

                    const clamped = Math.max(-100, Math.min(100, cents));
                    const offsetPx = (clamped / 200) * 320;
                    needleIndicator.style.left = `calc(50% + ${offsetPx}px)`;
                } else {
                    noteElem.textContent = lastNote;
                    freqElem.textContent = lastFreq;
                    centsElem.textContent = lastCents;
                }
            }
            loopId = requestAnimationFrame(update);
        }
        loopId = requestAnimationFrame(update);
    }

    function stopLoop() {
        if (loopId) {
            cancelAnimationFrame(loopId);
            loopId = null;
        }
    }

    // Init audio
    let micStream = null;
    let micSource = null;
    let micRequestPending = false;

    async function init() {
        updateBPMDialDisplay();
        const micPref = localStorage.getItem("micEnabled") || "false";
        document.getElementById("micToggle").style.display = "block";

        if (micPref === "true") {
            document.getElementById("micToggle").textContent = "Enable Mic";
            document.getElementById("status").textContent = "Mic: disabled";
        } else {
            resetTunerUI();
            document.getElementById("micToggle").textContent = "Enable Mic";
        }
    }

    function updatePauseMessages() {
        if (!micStream) {
            statusElem.textContent = "Mic: disabled";
        } else if (toneOscillator) {
            statusElem.textContent = "Tuner paused while tone is playing";
        } else if (metronomeInterval) {
            statusElem.textContent = "Tuner paused while metronome is on";
        } else {
            statusElem.textContent = "Mic: enabled";
        }
    }

    // Tone generator
    let audioCtx = null; //new (window.AudioContext || window.webkitAudioContext)();
    let toneOscillator = null;
    let toneGain = null;

    async function initAudioContext() {
        if (audioCtx === null || audioCtx.state === "closed") {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === "suspended") {
            await audioCtx.resume();
        }
    }

    function setPlayButtonState(enabled) {
        document.getElementById("playTone").disabled = !enabled;
    }

    function setPlayMetronomeButtonState(enabled) {
        document.getElementById("startMetronome").disabled = !enabled;
    }

    function dialToNote(index) {
        const A4 = 440;
        const semitoneOffset = index - 30;
        const f = A4 * Math.pow(2, semitoneOffset / 12);
        const n = 12 * Math.log2(f / A4);
        const nearest = Math.round(n);
        const noteIndex = nearest + 57;
        const octave = Math.floor(noteIndex / 12);
        const name = NOTE_STRINGS[((noteIndex % 12) + 12) % 12];
        return { name, octave, f };
    }

    function updateBPMDialDisplay() {
        const bpm = parseInt(document.getElementById("tempo").value, 10);
        document.getElementById("dialBPM").textContent = `BPM: ${bpm}`;
    }

    function updateDialDisplay() {
        // tone generator
        const idx = parseInt(document.getElementById("noteDial").value, 10);
        const { name, octave, f } = dialToNote(idx);
        document.getElementById("dialNote").textContent = `Note: ${name}${octave}`;
        document.getElementById("dialFreq").textContent = `Freq: ${f.toFixed(2)} Hz`;

        if (toneOscillator) {
            toneOscillator.frequency.setValueAtTime(f, audioCtx.currentTime);
            waveFreq = f; // update wavelength live
        }
    }

    function updateWaveform() {
        const wave = document.getElementById("waveform").value;
        const validTypes = ["sine","square","triangle","sawtooth"];

        stopTone(); // ensure no overlap

        if (validTypes.includes(wave)) {
            // If an oscillator is already running, just change its type
            if (toneOscillator) {
                toneOscillator.type = wave;
            } else {
                // If nothing is playing, start a new tone with this waveform
                const freq = waveFreq || 440;
                playTone(freq, wave);
            }
        } else {
            // For custom instruments, restart with the chosen type
            const freq = waveFreq || 440;
            playTone(freq, wave); // duration optional, defaults to sustain
        }
    }

    function playTone(freq, type = "sine") {
        stopTone();

        if (micStream) {
            micStream.getAudioTracks().forEach(track => track.enabled = false);
            statusElem.textContent = "Mic paused while tone is playing";
        }

        const validTypes = ["sine", "square", "triangle", "sawtooth"];

        if (validTypes.includes(type)) {
            // Standard oscillator
            toneOscillator = audioCtx.createOscillator();
            toneGain = audioCtx.createGain();

            toneOscillator.type = type;
            toneOscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

            toneGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            toneOscillator.connect(toneGain).connect(audioCtx.destination);
            toneOscillator.start();
        } else {
            // Custom instruments
            const startTime = audioCtx.currentTime;

            if (type === "piano") {
                ({ osc: toneOscillator, gain: toneGain } = playPianoTone(freq, startTime));
            } else if (type === "strings") {
                ({ osc: toneOscillator, gain: toneGain } = playStringTone(freq, startTime));
            } else if (type === "electricGuitar") {
                ({ osc: toneOscillator, gain: toneGain } = playElectricGuitarTone(freq, startTime));
            } else if (type === "acousticGuitar") {
                ({ osc: toneOscillator, gain: toneGain } = playAcousticGuitarTone(freq, startTime));
            } else {
                // fallback to square
                toneOscillator = audioCtx.createOscillator();
                toneGain = audioCtx.createGain();
                toneOscillator.type = "square";
                toneOscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);
                toneGain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                toneOscillator.connect(toneGain).connect(audioCtx.destination);
                toneOscillator.start();
            }
        }

        setPlayButtonState(false);
        setTunerActive(false);
        startWaveAnimation(freq);
        syncUIState();
        updatePauseMessages();
    }

    function stopTone() {
        if (toneOscillator) {
            try { toneOscillator.stop(); } catch(e) {console.warn(e);}
            toneOscillator.disconnect();
            toneOscillator = null;
        }
        if (toneGain) {
            toneGain.disconnect();
            toneGain = null;
        }

        // Resume mic if it was paused
        if (micStream) {
            micStream.getAudioTracks().forEach(track => track.enabled = true);
            statusElem.textContent = "Mic: enabled";
        }

        setPlayButtonState(true);
        setTunerActive(true);
        stopWaveAnimation();
        syncUIState();
        updatePauseMessages();
    }

    function changeDial(delta) {
        const dial = document.getElementById("noteDial");
        let val = parseInt(dial.value, 10);
        val = Math.max(parseInt(dial.min), Math.min(parseInt(dial.max), val + delta));
        dial.value = val;
        updateDialDisplay(); // reuse your existing function
    }

    // Metronome
    let metronomeInterval = null;
    let subdivisionInterval = null;
    let tapTimes = [];
    let tappingActive = false;
    let tapTimeout = null;
    let metronomeRunning = false;

    function playClick(strong = true, type = "main") {
        if (tappingActive) return;

        if (!audioCtx) audioCtx = new AudioContext();
        const now = audioCtx.currentTime;

        const soundChoice = document.getElementById("clickSound")?.value || "square";

        // --- choose sound source ---
        if (soundChoice === "hihat") {
            playHiHatBeat(now, 0.05);   // short crisp click
        } else if (soundChoice === "kick") {
            playKickBeat(now, 0.1);     // punchy downbeat
        } else if (soundChoice === "snare") {
            playSnareBeat(now, 0.1);    // snappy click
        } else if (soundChoice === "clap") {
            playClapBeat(now, 0.1);    // snappy click
        } else {
            // fallback: oscillator click
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.type = soundChoice; // e.g. "square", "sine", etc.

            if (type === "poly") {
                osc.frequency.setValueAtTime(1600, now);
                gain.gain.setValueAtTime(0.15, now);
            } else {
                osc.frequency.setValueAtTime(strong ? 1000 : 1500, now);
                gain.gain.setValueAtTime(strong ? 0.2 : 0.1, now);
            }

            osc.connect(gain).connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 0.05);
        }

        // --- dot flash logic stays the same ---
        let dot;
        if (type === "poly") {
            dot = document.getElementById("polyDot");
            dot.style.backgroundColor = "green";
        } else {
            dot = strong ? document.getElementById("metronomeDot")
                : document.getElementById("subdivisionDot");
        }

        dot.style.opacity = "1";

        const bpm = parseInt(document.getElementById("tempo").value, 10) || 120;
        const beatMs = 60000 / bpm;
        const subdivisions = parseInt(document.getElementById("subdivisions").value, 10) || 1;
        const subdivisionMs = beatMs / subdivisions;
        const blinkDuration = subdivisionMs * 0.2;

        setTimeout(() => { dot.style.opacity = "0"; }, blinkDuration);
    }

    function registerTap(e) {
        const ignoredIds = new Set(["startMetronome","stopMetronome","subdivisions","tempo","clickSound","polySubdivisions"]);
        if (ignoredIds.has(e.target.id)) return;
        e.preventDefault();

        const now = performance.now();
        tapTimes.push(now);
        if (tapTimes.length > 8) tapTimes.shift();

        // mark tapping active (mute ticks)
        tappingActive = true;

        if (tapTimes.length >= 2) {
            // Only update BPM if there are at least 2 taps
            const lastInterval = tapTimes[tapTimes.length - 1] - tapTimes[tapTimes.length - 2];
            const bpm = Math.round(60000 / lastInterval);

            if (bpm >= 30 && bpm <= 240) {
                tempo.value = bpm;
                document.getElementById("metronomeText").textContent = `Tapped tempo`;
                updateBPMDialDisplay();

                // If metronome is already running, restart with new BPM
                if (metronomeInterval) {
                    startMetronome();
                }
            }
        }

        // reset timeout: if no tap for 1s, unmute ticks
        clearTimeout(tapTimeout);
        tapTimeout = setTimeout(() => {
            tappingActive = false;
        }, 1000);
    }

    function startMetronome() {
        let tempoValue = tempo.value;
        if (tempoValue <= 0) {
            tempoValue = "120";
            tempo.value = tempoValue;
        }
        const bpm = parseInt(tempoValue, 10);
        const subdivisions = getSubdivisions();
        let polySubs = getPolySubdivisions();
        if (subdivisions === polySubs) {
            polySubs = 0;
        }

        const beatMs = 60000 / bpm;
        const subMs = beatMs / subdivisions;
        const polyMs = polySubs > 1 ? beatMs / polySubs : null;

        stopMetronome();

        metronomeInterval = setInterval(() => {
            // main beat
            playClick(true);

            // normal subdivisions
            if (subdivisions > 1) {
                for (let i = 1; i < subdivisions; i++) {
                    setTimeout(() => playClick(false), i * subMs);
                }
            }

            // polyrhythm pulses (stretch across the same beat)
            if (polyMs) {
                for (let i = 1; i < polySubs; i++) {
                    setTimeout(() => playClick(false, "poly"), i * polyMs);
                }
            }
        }, beatMs);

        document.getElementById("metronomeText").textContent =
            polySubs > 1
                ? `${subdivisions} subdivisions + ${polySubs}-pulse polyrhythm`
                : (subdivisions > 1
                    ? `${subdivisions} subdivisions`
                    : `Playing`);

        updateBPMDialDisplay();
        setElementState("startMetronome", false);
        metronomeRunning = true;
        syncUIState();
        updatePauseMessages();
        if (micStream) {
            micStream.getAudioTracks().forEach(track => track.enabled = false);
            statusElem.textContent = "Mic paused while tone is playing";
        }
    }

    function stopMetronome() {
        if (metronomeInterval) clearInterval(metronomeInterval);
        if (subdivisionInterval) clearInterval(subdivisionInterval); // safe no-op now
        metronomeInterval = null;
        subdivisionInterval = null;

        if (micStream) {
            micStream.getAudioTracks().forEach(track => track.enabled = true);
            statusElem.textContent = "Mic: enabled";
        }

        document.getElementById("metronomeText").textContent = `Stopped`;
        updateBPMDialDisplay();
        document.getElementById("metronomeDot").style.opacity = "0";
        document.getElementById("subdivisionDot").style.opacity = "0";
        setElementState("startMetronome", true);
        metronomeRunning = false;
        syncUIState();
        updatePauseMessages();
    }

    function getTempo() {
        const tempoField = document.getElementById("tempo");
        let bpm = parseInt(tempoField.value, 10);
        if (!bpm || bpm < 1) {
            bpm = 120; // default
            tempoField.value = bpm;
        }
        return bpm;
    }

    function getSubdivisions() {
        const subsField = document.getElementById("subdivisions");
        let subs = parseInt(subsField.value, 10);
        if (!subs || subs < 1) {
            subs = 0; // default
            subsField.value = subs;
        }
        return subs;
    }

    function getPolySubdivisions() {
        const subsField = document.getElementById("polySubdivisions");
        let subs = parseInt(subsField.value, 10);
        if (!subs || subs < 1) {
            subs = 0; // default
            subsField.value = subs;
        }
        return subs;
    }

    // Presets
    function initPresets() {
        if (typeof(Storage) === "undefined") {
            // localStorage not available
            return;
        }
        document.getElementById("presetsBox").style.display = "block";
        refreshPresetList();
    }

    function savePreset() {
        const bpm = getTempo();
        const subdivisions = getSubdivisions();
        const polySubdivisions = getPolySubdivisions();
        const noteDialVal = document.getElementById("noteDial").value;
        const waveformVal = document.getElementById("waveform").value;
        const clickSoundVal = document.getElementById("clickSound").value; // NEW

        const preset = { bpm, subdivisions, polySubdivisions, noteDialVal, waveformVal, clickSoundVal };
        const name = prompt("Preset name:");
        if (!name) return;

        if (typeof(Storage) !== "undefined") {
            localStorage.setItem("preset_" + name, JSON.stringify(preset));
        }
        refreshPresetList();
    }

    function loadPreset() {
        const select = document.getElementById("presetSelect");
        const key = select.value;
        if (!key) return;

        if (typeof(Storage) !== "undefined") {
            const preset = JSON.parse(localStorage.getItem(key));
            if (!preset) return;

            document.getElementById("tempo").value = preset.bpm;
            document.getElementById("metronomeText").textContent = `Stopped`
            updateBPMDialDisplay();
            document.getElementById("subdivisions").value = preset.subdivisions;
            document.getElementById("polySubdivisions").value = preset.polySubdivisions;
            document.getElementById("noteDial").value = preset.noteDialVal;
            document.getElementById("waveform").value = preset.waveformVal;
            if (preset.clickSoundVal) {
                document.getElementById("clickSound").value = preset.clickSoundVal;
            }

            updateDialDisplay();
        }
    }

    function deletePreset() {
        const select = document.getElementById("presetSelect");
        const key = select.value;
        if (!key) return;

        if (typeof(Storage) !== "undefined") {
            localStorage.removeItem(key);
        }
        refreshPresetList();
    }

    function refreshPresetList() {
        const select = document.getElementById("presetSelect");
        select.innerHTML = "";

        let hasPresets = false;
        if (typeof(Storage) !== "undefined") {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith("preset_")) {
                    const opt = document.createElement("option");
                    opt.value = key;
                    opt.textContent = key.replace("preset_", "");
                    select.appendChild(opt);
                    hasPresets = true;
                }
            }
        }

        // Show/hide dropdown + load/delete buttons depending on content
        select.style.display = hasPresets ? "inline-block" : "none";
        document.getElementById("loadPreset").style.display = hasPresets ? "inline-block" : "none";
        document.getElementById("deletePreset").style.display = hasPresets ? "inline-block" : "none";
    }

    function applyTheme(theme, custom = null) {
        document.body.className = '';

        if (theme === 'custom' && custom) {
            document.documentElement.style.setProperty('--input-font-color', custom.inputFont);
            document.documentElement.style.setProperty('--input-bg-color', custom.inputBg);
            document.documentElement.style.setProperty('--box-header-color', custom.boxHeader);
            document.documentElement.style.setProperty('--page-bg-color', custom.pageBg);
            document.documentElement.style.setProperty('--box-bg-color', custom.boxBg);
            document.documentElement.style.setProperty('--wave-color', custom.waveColor);
            adaptTextColors(custom.boxBg);
            if (typeof(Storage) !== "undefined") {
                localStorage.setItem('theme', 'custom'); // ensure theme is saved
            }
        } else {
            // Change to the theme passed
            const classTheme = 'theme-' + theme;
            document.body.classList.add(classTheme);
            const element = document.querySelector('.'+classTheme);
            const boxBg = getComputedStyle(element).getPropertyValue('--box-bg-color').trim();
            adaptTextColors(boxBg);
            if (typeof(Storage) !== "undefined") {
                localStorage.setItem('theme', theme); // save active theme
            }
        }
    }

    function saveTheme(theme, custom = null) {
        if (typeof(Storage) !== "undefined") {
            localStorage.setItem("theme", theme);
            if (custom) localStorage.setItem("customTheme", JSON.stringify(custom));
        }
    }

    function loadTheme() {
        if (typeof(Storage) !== "undefined") {
            const theme = localStorage.getItem("theme");
            const custom = localStorage.getItem("customTheme");
            if (theme) {
                const parsed = custom ? JSON.parse(custom) : null;
                applyTheme(theme, parsed);
                highlightSwatch(theme);
                if (theme === "custom") {
                    document.getElementById("customThemeInputs").style.display = "block";
                    setCustomInputs(parsed);   // populate color pickers
                }
            }
        }
    }

    function highlightSwatch(theme) {
        document.querySelectorAll(".theme-swatch").forEach(s => {
            s.classList.toggle("selected", s.dataset.theme === theme);
        });
    }

    function normalizeHex(hex) {
        hex = hex.replace('#','').trim();
        if (hex.length === 3) {
            // Expand shorthand (#111 → #111111)
            hex = hex.split('').map(c => c + c).join('');
        }
        return '#' + hex;
    }

    function getBrightness(color) {
        color = color.trim().toLowerCase();

        // Handle rgb/rgba
        if (color.startsWith('rgb')) {
            const parts = color.match(/\d+/g);
            if (!parts || parts.length < 3) return 128;
            const [r,g,b] = parts.map(Number);
            return (r*299 + g*587 + b*114) / 1000;
        }

        // Handle hex
        if (color.startsWith('#')) {
            const hex = normalizeHex(color);
            const r = parseInt(hex.substring(1,2),16);
            const g = parseInt(hex.substring(3,2),16);
            const b = parseInt(hex.substring(5,2),16);
            return (r*299 + g*587 + b*114) / 1000;
        }

        return 128; // safe fallback
    }

    function adaptTextColors(boxBg) {
        const brightness = getBrightness(boxBg);

        // If parsing failed, try resolving from CSS variable directly
        if (brightness === null) {
            const resolved = getComputedStyle(document.documentElement)
                .getPropertyValue('--box-bg-color').trim();
            const fallbackBrightness = getBrightness(resolved);
            // If still null, bail to a safe default
            const b = fallbackBrightness ?? 128;
            setAdaptiveStatusColors(b);
            return;
        }
        setAdaptiveStatusColors(brightness);
    }

    function setAdaptiveStatusColors(brightness) {
        // Two-tier contrast; tweak thresholds as needed
        if (brightness < 128) {
            document.documentElement.style.setProperty('--status-color', '#aaaaaa');
            document.documentElement.style.setProperty('--sub-color', '#aaaaaa');
        } else {
            document.documentElement.style.setProperty('--status-color', '#666666');
            document.documentElement.style.setProperty('--sub-color', '#666666');
        }
    }

    function getSavedCustomTheme() {
        if (typeof(Storage) !== "undefined") {
            const custom = localStorage.getItem("customTheme");
            return custom ? JSON.parse(custom) : null;
        } else  {
            return null;
        }
    }

    function setCustomInputs(custom) {
        if (!custom) return;
        document.getElementById("customInputFont").value = custom.inputFont;
        document.getElementById("customInputBg").value = custom.inputBg;
        document.getElementById("customBoxHeader").value = custom.boxHeader;
        document.getElementById("customPageBg").value = custom.pageBg;
        document.getElementById("customBoxBg").value = custom.boxBg;
        document.getElementById("customWaveColor").value = custom.waveColor;
    }

    loadTheme();

    // Initialize presets box on page load
    initPresets();

    function playMelody(melody = [], bpm = 300, onFinished) {
        if (!audioCtx) audioCtx = new AudioContext();

        const beatMs = 60000 / bpm;
        const beatSec = beatMs / 1000;
        let startTime = audioCtx.currentTime;
        let totalDuration = 0;

        melody.forEach(step => {
            // determine step length by shortest note
            let stepBeats;
            if (typeof step.dur === "number" && isFinite(step.dur)) {
                stepBeats = step.dur;
            } else if (step.notes && Array.isArray(step.notes) && step.notes.length > 0) {
                stepBeats = Math.min(...step.notes.map(n =>
                    (typeof n.dur === "number" && isFinite(n.dur)) ? n.dur : Infinity
                ));
            } else {
                stepBeats = 0;
            }

            const stepDuration = beatSec * stepBeats;

            if (step.notes && Array.isArray(step.notes)) {
                step.notes.forEach(n => {
                    let freq = null;
                    if (typeof n.freq === "number" && isFinite(n.freq)) {
                        freq = n.freq;
                    } else if (n.note) {
                        freq = noteToFrequency(n.note);
                    }

                    if (freq) {
                        const noteDuration = beatSec * n.dur;
                        if (n.instrument === "piano") {
                            playPianoTone(freq, startTime, noteDuration);
                        } else if (n.instrument === "strings") {
                            playStringTone(freq, startTime, noteDuration);
                        } else if (n.instrument === "electricGuitar") {
                            playElectricGuitarTone(freq, startTime, noteDuration);
                        } else if (n.instrument === "acousticGuitar") {
                            playAcousticGuitarTone(freq, startTime, noteDuration);
                        } else {
                            // default oscillator
                            const osc = audioCtx.createOscillator();
                            const gain = audioCtx.createGain();
                            osc.type = n.instrument || "square";
                            osc.frequency.setValueAtTime(freq, startTime);
                            gain.gain.setValueAtTime(0.2, startTime);
                            osc.connect(gain).connect(audioCtx.destination);
                            osc.start(startTime);
                            osc.stop(startTime + noteDuration);
                        }
                    }
                });
            } else {
                // single note or freq
                let freq = null;
                if (typeof step.freq === "number" && isFinite(step.freq)) {
                    freq = step.freq;
                } else if (step.note) {
                    freq = noteToFrequency(step.note);
                }

                if (step.type !== "rest" && freq) {
                    const noteDuration = beatSec * step.dur;
                    if (step.instrument === "piano") {
                        playPianoTone(freq, startTime, noteDuration);
                    } else if (step.instrument === "strings") {
                        playStringTone(freq, startTime, noteDuration);
                    } else if (step.instrument === "electricGuitar") {
                        playElectricGuitarTone(freq, startTime, noteDuration);
                    } else if (step.instrument === "acousticGuitar") {
                        playAcousticGuitarTone(freq, startTime, noteDuration);
                    } else {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.type = step.instrument || "square";
                        osc.frequency.setValueAtTime(freq, startTime);
                        gain.gain.setValueAtTime(0.2, startTime);
                        osc.connect(gain).connect(audioCtx.destination);
                        osc.start(startTime);
                        osc.stop(startTime + noteDuration);
                    }
                }
            }

            // advance timeline by shortest duration
            totalDuration += stepDuration;
            startTime += stepDuration;
        });

        // schedule callback when finished
        if (typeof onFinished === "function") {
            setTimeout(() => {
                onFinished();
            }, totalDuration * 1000);
        }
    }

    function playPianoTone(freq, startTime, duration) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "sine"; // fundamental tone
        osc.frequency.setValueAtTime(freq, startTime);

        // Envelope: sharp attack, quick decay, natural release
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.9, startTime + 0.01); // hammer strike
        gain.gain.linearRampToValueAtTime(0.4, startTime + 0.15); // decay

        osc.connect(gain).connect(audioCtx.destination);
        osc.start(startTime);

        if (duration) {
            gain.gain.linearRampToValueAtTime(0, startTime + duration); // release
            osc.stop(startTime + duration);
        }

        return { osc, gain };
    }

    function playStringTone(freq, startTime, duration) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = "sawtooth";
        osc.frequency.setValueAtTime(freq, startTime);

        // Envelope: slow attack, steady sustain, gentle release
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.6, startTime + 0.5); // attack

        filter.type = "lowpass";
        filter.frequency.setValueAtTime(500, startTime);

        osc.connect(filter).connect(gain).connect(audioCtx.destination);
        osc.start(startTime);

        if (duration) {
            // scheduled release
            gain.gain.setValueAtTime(0.6, startTime + duration - 0.3); // sustain
            gain.gain.linearRampToValueAtTime(0, startTime + duration);
            osc.stop(startTime + duration);
        }

        return { osc, gain };
    }

    function playElectricGuitarTone(freq, startTime, duration) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        osc.type = "sawtooth"; // bright harmonic content
        osc.frequency.setValueAtTime(freq, startTime);

        // Envelope: sharp attack, sustain, release
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.8, startTime + 0.02); // fast attack

        // Filter to tame harshness
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(2500, startTime);

        osc.connect(filter).connect(gain).connect(audioCtx.destination);
        osc.start(startTime);

        if (duration) {
            // scheduled release
            gain.gain.setValueAtTime(0.6, startTime + duration - 0.1); // sustain
            gain.gain.linearRampToValueAtTime(0, startTime + duration);
            osc.stop(startTime + duration);
        }

        return { osc, gain };
    }

    function playAcousticGuitarTone(freq, startTime, duration) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "triangle"; // softer harmonic profile
        osc.frequency.setValueAtTime(freq, startTime);

        // Envelope: pluck attack, quick decay
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(1.0, startTime + 0.01); // sharp pluck
        gain.gain.linearRampToValueAtTime(0.3, startTime + 0.1);  // quick decay

        osc.connect(gain).connect(audioCtx.destination);
        osc.start(startTime);

        if (duration) {
            // scheduled release
            gain.gain.linearRampToValueAtTime(0, startTime + duration);
            osc.stop(startTime + duration);
        }

        return { osc, gain };
    }

    function noteToFrequency(note) {
        const A4 = 440;
        const notes = {
            "C": -9, "C#": -8, "Db": -8,
            "D": -7, "D#": -6, "Eb": -6,
            "E": -5,
            "F": -4, "F#": -3, "Gb": -3,
            "G": -2, "G#": -1, "Ab": -1,
            "A": 0, "A#": 1, "Bb": 1,
            "B": 2
        };

        // split note string into pitch + octave
        const match = note.match(/^([A-G]#?|[A-G]b?)(\d)$/);
        if (!match) return null;

        const pitch = match[1];
        const octave = parseInt(match[2], 10);

        // semitone distance from A4
        const semitones = notes[pitch] + (octave - 4) * 12;
        return A4 * Math.pow(2, semitones / 12);
    }

    // hihat, kick, clap or snare
    function playBeat(beatPattern = [], bpm = 300) {
        if (!audioCtx) audioCtx = new AudioContext();

        const beatMs = 60000 / bpm;
        const beatSec = beatMs / 1000;
        let startTime = audioCtx.currentTime;

        beatPattern.forEach(step => {
            let stepBeats;

            if (typeof step.dur === "number" && isFinite(step.dur)) {
                // explicit duration
                stepBeats = step.dur;
            } else if (step.types && Array.isArray(step.types) && step.types.length > 0) {
                // compound types → shortest duration
                stepBeats = Math.min(...step.types.map(t => {
                    if (typeof t === "string") return 1;
                    if (typeof t === "object" && typeof t.dur === "number" && isFinite(t.dur)) {
                        return t.dur;
                    }
                    return 1;
                }));
            } else {
                // default
                stepBeats = 1;
            }

            const stepDuration = beatSec * stepBeats;

            if (step.type !== "rest") {
                // single type
                if (step.type) {
                    const dur = step.dur || stepBeats;
                    scheduleHit(step.type, startTime, dur * beatSec);
                }

                // multiple types
                if (step.types && Array.isArray(step.types)) {
                    step.types.forEach(t => {
                        let typeName, hitDur;
                        if (typeof t === "string") {
                            typeName = t;
                            hitDur = stepBeats; // default
                        } else if (typeof t === "object") {
                            typeName = t.type;
                            hitDur = t.dur || stepBeats;
                        }
                        scheduleHit(typeName, startTime, hitDur * beatSec);
                    });
                }
            }

            // visual dot flash
            setTimeout(() => {
                const dot = document.getElementById("metronomeDot");
                if (dot) {
                    dot.style.opacity = "1";
                    setTimeout(() => { dot.style.opacity = "0"; }, beatMs * stepBeats);
                }
            }, (startTime - audioCtx.currentTime) * 1000);

            // advance timeline by shortest duration
            startTime += stepDuration;
        });
    }

    function scheduleHit(type, time, duration) {
        if (type === "hihat") playHiHatBeat(time, duration);
        else if (type === "kick") playKickBeat(time, duration);
        else if (type === "snare") playSnareBeat(time, duration);
        else if (type === "clap") playClapBeat(time, duration);
    }

    function playHiHatBeat(time, duration = 0.2) {
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        // high shimmer
        const highpass = audioCtx.createBiquadFilter();
        highpass.type = "highpass";
        highpass.frequency.value = 8000;

        // metallic band (still noise, not pitched)
        const bandpass = audioCtx.createBiquadFilter();
        bandpass.type = "bandpass";
        bandpass.frequency.value = 9000;
        bandpass.Q.value = 1.5;

        // envelope gain (boosted)
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(1.2, time); // louder start
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);

        // master gain stage
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 1.5; // global boost

        // connect both filters to gain → master
        noise.connect(highpass).connect(gain).connect(masterGain).connect(audioCtx.destination);
        noise.connect(bandpass).connect(gain).connect(masterGain).connect(audioCtx.destination);

        noise.start(time);
        noise.stop(time + duration);
    }

    function playKickBeat(time, duration = 0.3) {
        // Sub-bass sine sweep
        const osc = audioCtx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(150, time);
        osc.frequency.exponentialRampToValueAtTime(50, time + 0.1);

        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(1.5, time); // stronger fundamental
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);

        // Attack click (short noise burst)
        const bufferSize = audioCtx.sampleRate * 0.02; // 20ms
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const noiseGain = audioCtx.createGain();
        noiseGain.gain.setValueAtTime(0.8, time); // louder click
        noiseGain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

        // Harmonic layer for body
        const osc2 = audioCtx.createOscillator();
        osc2.type = "triangle";
        osc2.frequency.value = 100;
        const gain2 = audioCtx.createGain();
        gain2.gain.setValueAtTime(0.5, time); // adds midrange punch
        gain2.gain.exponentialRampToValueAtTime(0.001, time + 0.15);

        // Connect chains
        osc.connect(gain).connect(audioCtx.destination);
        noise.connect(noiseGain).connect(audioCtx.destination);
        osc2.connect(gain2).connect(audioCtx.destination);

        // Start/stop
        osc.start(time);
        osc.stop(time + duration);
        noise.start(time);
        noise.stop(time + 0.05);
        osc2.start(time);
        osc2.stop(time + 0.15);
    }

    function playSnareBeat(time, duration = 0.2) {
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        // Crack (strong transient)
        const crackFilter = audioCtx.createBiquadFilter();
        crackFilter.type = "bandpass";
        crackFilter.frequency.value = 3500;
        const crackGain = audioCtx.createGain();
        crackGain.gain.setValueAtTime(2.0, time); // much louder
        crackGain.gain.exponentialRampToValueAtTime(0.001, time + 0.06);

        // Body (short but boosted)
        const bodyFilter = audioCtx.createBiquadFilter();
        bodyFilter.type = "bandpass";
        bodyFilter.frequency.value = 1200;
        const bodyGain = audioCtx.createGain();
        bodyGain.gain.setValueAtTime(1.2, time); // louder body
        bodyGain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);

        // Air (bright shimmer, boosted)
        const airFilter = audioCtx.createBiquadFilter();
        airFilter.type = "bandpass";
        airFilter.frequency.value = 9000;
        const airGain = audioCtx.createGain();
        airGain.gain.setValueAtTime(0.8, time); // brighter
        airGain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);

        // Master gain stage to ensure loudness
        const masterGain = audioCtx.createGain();
        masterGain.gain.value = 1.5; // global boost

        // Connect chains
        noise.connect(crackFilter).connect(crackGain).connect(masterGain).connect(audioCtx.destination);
        noise.connect(bodyFilter).connect(bodyGain).connect(masterGain).connect(audioCtx.destination);
        noise.connect(airFilter).connect(airGain).connect(masterGain).connect(audioCtx.destination);

        noise.start(time);
        noise.stop(time + duration);
    }

    function playClapBeat(time, duration = 0.12) {
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        // Pink-ish noise: accumulate to reduce high-frequency harshness
        let b0 = 0, b1 = 0, b2 = 0;
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.997 * b0 + white * 0.05;
            b1 = 0.985 * b1 + white * 0.1;
            b2 = 0.940 * b2 + white * 0.2;
            data[i] = b0 + b1 + b2 + white * 0.05;
        }

        // Filters
        const bandpass = audioCtx.createBiquadFilter();
        bandpass.type = "bandpass";
        bandpass.frequency.value = 2000; // slightly lower
        bandpass.Q.value = 2.5;          // tighter band

        const highpass = audioCtx.createBiquadFilter();
        highpass.type = "highpass";
        highpass.frequency.value = 800;  // remove low rumble

        // Burst offsets (simulate multiple hands)
        const bursts = [0, 0.02, 0.04];
        bursts.forEach((offset, idx) => {
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(1.0 - idx * 0.3, time + offset);
            gain.gain.exponentialRampToValueAtTime(0.001, time + offset + 0.08);

            noise.connect(highpass).connect(bandpass).connect(gain).connect(audioCtx.destination);
            noise.start(time + offset);
            noise.stop(time + offset + 0.1);
        });
    }

    // Events
    document.getElementById("playSimpleSong").addEventListener("click", function () {
        if (songPlaying === false) {
            songPlaying = true;
            const beatPattern = [
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 },
                { type: "hihat", dur: 2 }
            ];

            const melody = [
                { note: "A5", dur: 1 },
                { note: "rest", dur: 1 },
                { note: "G#5", dur: 1 },
                { note: "E5", dur: 1 },
                { note: "rest", dur: 1 },
                { note: "A5", dur: 1 },
                { note: "rest", dur: 1 },
                { note: "G#5", dur: 1 },
                { note: "rest", dur: 3 },
                { note: "E5", dur: 2 },
                { note: "E5", dur: 2 },
                { note: "D5", dur: 0.5 },
                { note: "rest", dur: 0.5 },
                { note: "D5", dur: 6 }
            ];

            playBeat(beatPattern);
            playMelody(melody, 300, () => {
                songPlaying = false;
            });
        }
    });

    function getBeatPattern() {
        return [
            {type: "rest", dur: 4},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1},
            {
                types: [
                    {type: "kick", dur: 2},
                    {type: "snare", dur: 2},
                    {type: "clap", dur: 1},
                ]
            },
            {type: "hihat", dur: 1}
        ];
    }

    function getMelodyPattern() {
        return [
            {note: "F#6", dur: 0.5, instrument: "electricGuitar"}, // Intro - 16ths
            {note: "C#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "B5", dur: 0.5, instrument: "electricGuitar"},
            {note: "F#5", dur: 0.5, instrument: "electricGuitar"},
            {note: "B5", dur: 0.5, instrument: "electricGuitar"},
            {note: "C#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "F#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "C#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "B5", dur: 0.5, instrument: "electricGuitar"},
            {note: "F#5", dur: 0.5, instrument: "electricGuitar"},
            {note: "B5", dur: 0.5, instrument: "electricGuitar"},
            {note: "C#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "F#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "C#6", dur: 0.5, instrument: "electricGuitar"},
            {note: "B5", dur: 0.5, instrument: "electricGuitar"},
            {note: "F#5", dur: 0.5, instrument: "electricGuitar"},
            {note: "E2", dur: 1, instrument: "electricGuitar"}, // Melody - 8ths
            {note: "E3", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "B5", dur: 1, instrument: "electricGuitar"},
                    {note: "E5", dur: 1, instrument: "electricGuitar"},
                    {note: "F#5", dur: 1, instrument: "electricGuitar"},
                    {note: "A5", dur: 1, instrument: "electricGuitar"},
                    {note: "E2", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "E3", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "B5", dur: 1, instrument: "electricGuitar"},
                    {note: "E5", dur: 1, instrument: "electricGuitar"},
                    {note: "G#5", dur: 1, instrument: "electricGuitar"},
                    {note: "E2", dur: 1, instrument: "electricGuitar"}
                ]},
            {notes: [
                    {note: "B5", dur: 1, instrument: "electricGuitar"},
                    {note: "E5", dur: 1, instrument: "electricGuitar"},
                    {note: "E3", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "E2", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "B5", dur: 1, instrument: "electricGuitar"},
                    {note: "E5", dur: 1, instrument: "electricGuitar"},
                    {note: "F#5", dur: 1, instrument: "electricGuitar"},
                    {note: "A5", dur: 1, instrument: "electricGuitar"},
                    {note: "E3", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "E2", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "B5", dur: 1, instrument: "electricGuitar"},
                    {note: "E5", dur: 1, instrument: "electricGuitar"},
                    {note: "G#5", dur: 1, instrument: "electricGuitar"},
                    {note: "E3", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "E2", dur: 1, instrument: "electricGuitar"},
            {note: "E3", dur: 1, instrument: "electricGuitar"},
            {note: "E2", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "B5", dur: 2, instrument: "electricGuitar"},
                    {note: "E5", dur: 2, instrument: "electricGuitar"},
                    {note: "G#5", dur: 2, instrument: "electricGuitar"},
                    {note: "E3", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "E2", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "B5", dur: 2, instrument: "electricGuitar"},
                    {note: "E5", dur: 2, instrument: "electricGuitar"},
                    {note: "G#5", dur: 2, instrument: "electricGuitar"},
                    {note: "E3", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "D2", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "A5", dur: 1, instrument: "electricGuitar"},
                    {note: "F#5", dur: 1, instrument: "electricGuitar"},
                    {note: "D5", dur: 1, instrument: "electricGuitar"},
                    {note: "A5", dur: 1, instrument: "electricGuitar"},
                    {note: "D3", dur: 1, instrument: "electricGuitar"}
                ]},
            {notes: [
                    {note: "A5", dur: 2, instrument: "electricGuitar"},
                    {note: "F#5", dur: 2, instrument: "electricGuitar"},
                    {note: "D5", dur: 2, instrument: "electricGuitar"},
                    {note: "A5", dur: 2, instrument: "electricGuitar"},
                    {note: "D2", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "D3", dur: 1, instrument: "electricGuitar"},
            {notes: [
                    {note: "A5", dur: 4, instrument: "electricGuitar"},
                    {note: "F#5", dur: 4, instrument: "electricGuitar"},
                    {note: "D5", dur: 4, instrument: "electricGuitar"},
                    {note: "A5", dur: 4, instrument: "electricGuitar"},
                    {note: "D2", dur: 1, instrument: "electricGuitar"}
                ]},
            {note: "D3", dur: 1, instrument: "electricGuitar"},
            {note: "D2", dur: 1, instrument: "electricGuitar"},
            {note: "D3", dur: 1, instrument: "electricGuitar"}
        ];
    }

    document.getElementById("playSong").addEventListener("click", function () {
        if (songPlaying === false) {
            songPlaying = true;

            playBeat(getBeatPattern(), 150);
            playMelody(getMelodyPattern(), 300, () => {
                songPlaying = false;
            });
        }
    });

    window.addEventListener("DOMContentLoaded", () => {
        if (typeof(Storage) !== "undefined") {
            updatePauseMessages();
            document.getElementById("micToggle").textContent = "Enable Mic";
            document.getElementById("micToggle").style.display = "block";
            statusElem.textContent = "Mic: disabled";
        }
    });

    // Presets
    document.getElementById("savePreset").addEventListener("click", savePreset);
    document.getElementById("loadPreset").addEventListener("click", loadPreset);
    document.getElementById("deletePreset").addEventListener("click", deletePreset);

    // Custom themes
    document.querySelectorAll(".theme-swatch").forEach(swatch => {
        swatch.addEventListener("click", () => {
            const theme = swatch.dataset.theme;
            highlightSwatch(theme);

            if (theme === "custom") {
                const custom = getSavedCustomTheme();
                if (custom) {
                    applyTheme("custom", custom);
                    setCustomInputs(custom); // populate pickers
                }
                document.getElementById("customThemeInputs").style.display = "block";
            } else {
                document.getElementById("customThemeInputs").style.display = "none";
                applyTheme(theme);
                saveTheme(theme);
            }
        });
    });

    ["customInputFont","customInputBg","customBoxHeader","customPageBg","customBoxBg","customWaveColor"].forEach(id => {
        document.getElementById(id).addEventListener("input", () => {
            const custom = {
                inputFont: document.getElementById("customInputFont").value,
                inputBg: document.getElementById("customInputBg").value,
                boxHeader: document.getElementById("customBoxHeader").value,
                pageBg: document.getElementById("customPageBg").value,
                boxBg: document.getElementById("customBoxBg").value,
                waveColor: document.getElementById("customWaveColor").value
            };
            applyTheme("custom", custom);
            saveTheme("custom", custom);
            highlightSwatch("custom");
        });
    });

    // Metronome
    metronomeBox.addEventListener("pointerdown", (e) => {
        // Ignore clicks on controls inside the metronome box
        if (e.target.closest("input, select, button")) return;

        // Only allow tap-tempo if metronome mode is active
        if (!metronomeBoxEnabled) return;

        if (metronomeInterval) {
            // Metronome is running → allow tap to adjust tempo
            stopTone();
            registerTap(e);
            syncUIState(); // dim other boxes because metronome is actually playing
        } else {
            // Metronome is not running → allow tap-tempo, but do NOT dim other boxes
            registerTap(e);
            // no syncUIState() here
        }
    });

    document.getElementById("tempoSliderNotch").addEventListener("click", () => {
        tempo.value = 120;

        // Trigger any input event listeners bound to the slider
        tempo.dispatchEvent(new Event("input", { bubbles: true }));
    });
    document.getElementById("startMetronome").addEventListener("click", () => {
        stopTone();
        startMetronome();
        syncUIState();
        updatePauseMessages();
    });
    document.getElementById("stopMetronome").addEventListener("click", () => {
        stopMetronome();
        syncUIState();
    });
    document.getElementById("tempo").addEventListener("input", () => {
        if (metronomeInterval) {
            startMetronome(); // restart with new BPM
        }
    });
    document.getElementById("subdivisions").addEventListener("change", () => {
        if (metronomeInterval) {
            startMetronome();
        }
    });
    document.getElementById("polySubdivisions").addEventListener("change", () => {
        if (metronomeInterval) {
            startMetronome();
        }
    });
    tempo.addEventListener("input", () => {
        if (metronomeInterval) {
            startMetronome(); // restart with new BPM
        }
    });
    tempoUp.addEventListener("click", () => {
        tempo.value = Math.min(parseInt(tempo.value, 10) + 1, parseInt(tempo.max, 10));

        if (metronomeRunning) {
            document.getElementById("metronomeText").textContent = `Playing`;
        } else {
            document.getElementById("metronomeText").textContent = `Stopped`;
        }

        updateBPMDialDisplay();

        if (metronomeInterval) {
            startMetronome();
        }
    });
    tempoDown.addEventListener("click", () => {
        tempo.value = Math.max(parseInt(tempo.value, 10) - 1, parseInt(tempo.min, 10));

        if (metronomeRunning) {
            document.getElementById("metronomeText").textContent = `Playing`;
        } else {
            document.getElementById("metronomeText").textContent = `Stopped`;
        }

        updateBPMDialDisplay();

        if (metronomeInterval) {
            startMetronome();
        }
    });

    // Tone generator
    document.getElementById("sliderNotch").addEventListener("click", () => {
        const min = parseInt(noteDial.min, 10);
        const max = parseInt(noteDial.max, 10);
        noteDial.value = (min + max) / 2;

        // Trigger any input event listeners bound to the slider
        noteDial.dispatchEvent(new Event("input", { bubbles: true }));
    });
    document.getElementById("decrementNote").addEventListener("click", () => {
        changeDial(-1);
    });
    document.getElementById("incrementNote").addEventListener("click", () => {
        changeDial(1);
    });
    document.getElementById("tempo").addEventListener("input", () => {
        if (metronomeRunning) {
            const subdivisions = parseInt(getSubdivisions(), 10);
            document.getElementById("metronomeText").textContent = (subdivisions > 1) ? `${subdivisions} subdivisions` : `Playing`;
        } else {
            document.getElementById("metronomeText").textContent = `Stopped`;
        }

        updateBPMDialDisplay();
    });
    document.getElementById("noteDial").addEventListener("input", () => {
        updateDialDisplay();
    });
    document.getElementById("waveform").addEventListener("change", () => {
        if (toneOscillator) {
            updateWaveform();
        }
    });
    document.getElementById("playTone").addEventListener("click", () => {
        const idx = parseInt(document.getElementById("noteDial").value, 10);
        const { f } = dialToNote(idx);
        const wave = document.getElementById("waveform").value;
        playTone(f, wave);
        syncUIState();
        updatePauseMessages();
    });
    document.getElementById("stopTone").addEventListener("click", () => {
        stopTone();
        syncUIState();
        updatePauseMessages();
    });
    document.querySelectorAll('.copy-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const code = btn.nextElementSibling.innerText;
            navigator.clipboard.writeText(code).then(() => {
                btn.textContent = "Copied!";
                setTimeout(() => btn.textContent = "Copy", 1500);
            });
        });
    });

    document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
            e.preventDefault();

            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                if (toneOscillator) {
                    stopTone();
                } else {
                    const idx = parseInt(document.getElementById("noteDial").value, 10);
                    const { f } = dialToNote(idx);
                    const wave = document.getElementById("waveform").value;
                    playTone(f, wave);
                }
                syncUIState();
                updatePauseMessages();
            } else if (metronomeBoxEnabled) {
                if (metronomeInterval) {
                    stopMetronome();
                    setPlayMetronomeButtonState(true);
                } else {
                    stopTone();
                    startMetronome();
                    setPlayMetronomeButtonState(false);
                }
                syncUIState();
            }
        } else if (e.code === "ArrowRight") { // Higher pitch
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(1);
            }
        } else if (e.code === "ArrowLeft") { // Lower pitch
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(-1);
            }
        } else if (e.code === "KeyD") { // Higher pitch
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(1);
            }
        } else if (e.code === "KeyA") { // Lower pitch
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                changeDial(-1);
            }
        } else if (e.code === "KeyE") { // Change waveform
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                const waveformSelect = document.getElementById("waveform");
                const options = Array.from(waveformSelect.options);
                let idx = waveformSelect.selectedIndex;
                idx = (idx - 1 + options.length) % options.length;
                waveformSelect.selectedIndex = idx;
                updateWaveform(); // reuse your existing function
            }
        } else if (e.code === "KeyQ") { // Change waveform
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                const waveformSelect = document.getElementById("waveform");
                const options = Array.from(waveformSelect.options);
                let idx = waveformSelect.selectedIndex;
                idx = (idx + 1) % options.length;
                waveformSelect.selectedIndex = idx;
                updateWaveform();
            }
        } else if (e.code === "ShiftLeft" || e.code === "ShiftRight") { // Reset tone to A4
            if (metronomeBoxEnabled === false || (metronomeBoxEnabled && toneEnabled)) {
                const dial = document.getElementById("noteDial");
                // A4 is the center reference (index 30 in your mapping)
                dial.value = 30;
                updateDialDisplay();

                // If tone is playing, reset its frequency immediately
                const { f } = dialToNote(30);
                if (toneOscillator) {
                    toneOscillator.frequency.setValueAtTime(f, audioCtx.currentTime);
                }
            } else if (metronomeBoxEnabled) {
                const bpm = 120;
                const intervalMs = 60000 / bpm;

                if (metronomeInterval) clearInterval(metronomeInterval);

                // drive both click + blink from the same interval
                metronomeInterval = setInterval(() => {
                    playClick();
                }, intervalMs);

                document.getElementById("tempo").value = bpm;
                document.getElementById("metronomeText").textContent = `Playing`;
                updateBPMDialDisplay();
                updatePauseMessages();
            }
        } else if (e.code === "ArrowUp") { // Increase tempo
            if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.min(240, bpm + 1); // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing`;
                updateBPMDialDisplay();
                if (metronomeInterval) {
                    startMetronome(); // restart with new BPM
                }
            }
        } else if (e.code === "ArrowDown") { // Decrease tempo
            if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.max(30, bpm - 1); // floor at 30 // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing`;
                updateBPMDialDisplay();
                if (metronomeInterval) {
                    startMetronome(); // restart with new BPM
                }
            }
        } else if (e.code === "KeyW") { // Increase tempo
            if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.min(240, bpm + 1); // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing`;
                updateBPMDialDisplay();
                startMetronome();
            }
        } else if (e.code === "KeyS") { // Decrease tempo
            if (metronomeInterval && (toneEnabled === false || (metronomeBoxEnabled && toneEnabled))) {
                const tempoInput = document.getElementById("tempo");
                let bpm = getTempo();
                bpm = Math.max(30, bpm - 1); // floor at 30 // cap at 240
                tempoInput.value = bpm;
                document.getElementById("metronomeText").textContent = `Playing`;
                updateBPMDialDisplay();
                startMetronome();
            }
        }
    });

    // Initialize dial display
    updateDialDisplay();
    init();
</script>
</body>
</html>